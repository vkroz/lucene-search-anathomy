<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lucene-core-API: org.apache.lucene.index.IndexWriter Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lucene-core-API
   &#160;<span id="projectnumber">8.0.0-SNAPSHOT</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="../../d4/d28/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">org.apache.lucene.index.IndexWriter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> creates and maintains an index.  
 <a href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for org.apache.lucene.index.IndexWriter:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/d50/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer__inherit__graph.png" border="0" usemap="#org_8apache_8lucene_8index_8_index_writer_inherit__map" alt="Inheritance graph"/></div>
<map name="org_8apache_8lucene_8index_8_index_writer_inherit__map" id="org_8apache_8lucene_8index_8_index_writer_inherit__map">
<area shape="rect" id="node3" href="../../de/d0f/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_two_phase_commit.html" title="An interface for implementations that support 2&#45;phase commit. " alt="" coords="35,57,205,98"/>
<area shape="rect" id="node4" href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html" title="An object whose RAM usage can be computed. " alt="" coords="5,123,235,149"/>
<area shape="rect" id="node5" href="../../d2/d9b/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy_1_1_merge_context.html" title="This interface represents the current context of the merge selection process. " alt="" coords="29,174,211,215"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for org.apache.lucene.index.IndexWriter:</div>
<div class="dyncontent">
<div class="center"><img src="../../d5/db9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer__coll__graph.png" border="0" usemap="#org_8apache_8lucene_8index_8_index_writer_coll__map" alt="Collaboration graph"/></div>
<map name="org_8apache_8lucene_8index_8_index_writer_coll__map" id="org_8apache_8lucene_8index_8_index_writer_coll__map">
<area shape="rect" id="node7" href="../../dd/d43/classorg_1_1apache_1_1lucene_1_1util_1_1_info_stream.html" title="Debugging API for Lucene classes such as IndexWriter and SegmentInfos. " alt="" coords="181,811,360,853"/>
<area shape="rect" id="node19" title="This class accepts multiple added documents and directly writes segment files. " alt="" coords="1151,379,1322,421"/>
<area shape="rect" id="node38" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html" title="org.apache.lucene.index.\lMergeScheduler" alt="" coords="677,733,848,774"/>
<area shape="rect" id="node3" href="../../de/d0f/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_two_phase_commit.html" title="An interface for implementations that support 2&#45;phase commit. " alt="" coords="1151,1066,1322,1107"/>
<area shape="rect" id="node4" href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html" title="An object whose RAM usage can be computed. " alt="" coords="156,185,385,212"/>
<area shape="rect" id="node9" title="Tracks the stream of FrozenBufferedUpdates. " alt="" coords="925,151,1096,193"/>
<area shape="rect" id="node20" title="This class controls DocumentsWriterPerThread flushing during indexing. " alt="" coords="663,379,863,421"/>
<area shape="rect" id="node24" title="DocumentsWriterDeleteQueue is a non&#45;blocking linked pending deletes queue. " alt="" coords="661,262,865,303"/>
<area shape="rect" id="node5" href="../../d2/d9b/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy_1_1_merge_context.html" title="This interface represents the current context of the merge selection process. " alt="" coords="1145,1131,1328,1173"/>
<area shape="rect" id="node26" title="FlushPolicy controls when segments are flushed from a RAM resident internal data&#45;structure to the Ind..." alt="" coords="677,927,848,969"/>
<area shape="rect" id="node27" href="../../d6/d17/classorg_1_1apache_1_1lucene_1_1index_1_1_live_index_writer_config.html" title="Holds all the configuration used by IndexWriter with few setters for settings that can be changed on ..." alt="" coords="1151,929,1322,970"/>
<area shape="rect" id="node11" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html" title="A collection of segmentInfo objects with methods for operating on those segments in relation to the f..." alt="" coords="1151,1406,1322,1447"/>
<area shape="rect" id="node16" href="../../d5/d8c/classorg_1_1apache_1_1lucene_1_1codecs_1_1_codec.html" title="Encodes/decodes an inverted index segment. " alt="" coords="672,562,853,603"/>
<area shape="rect" id="node17" title="Interface to support NamedSPILoader#lookup(String) by name. " alt="" coords="136,521,405,577"/>
<area shape="rect" id="node21" title="Controls the health status of a DocumentsWriter sessions. " alt="" coords="174,382,367,423"/>
<area shape="rect" id="node23" title="DocumentsWriterPerThreadPool controls ThreadState instances and their thread assignments during index..." alt="" coords="655,497,870,538"/>
<area shape="rect" id="node28" href="../../d8/dcd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_deletion_policy.html" title="org.apache.lucene.index.\lIndexDeletionPolicy" alt="" coords="677,862,848,903"/>
<area shape="rect" id="node29" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html" title="org.apache.lucene.index.\lMergePolicy" alt="" coords="677,1175,848,1217"/>
<area shape="rect" id="node30" href="../../db/d21/classorg_1_1apache_1_1lucene_1_1search_1_1_sort.html" title="Encapsulates sort criteria for returned hits. " alt="" coords="661,681,865,708"/>
<area shape="rect" id="node31" href="../../de/d08/classorg_1_1apache_1_1lucene_1_1search_1_1_sort_field.html" title="Stores information about how to sort documents by terms in an individual field. " alt="" coords="181,655,360,697"/>
<area shape="rect" id="node33" title="Specifies the open mode for IndexWriter. " alt="" coords="663,1045,862,1086"/>
<area shape="rect" id="node34" href="../../d9/dba/classorg_1_1apache_1_1lucene_1_1index_1_1_index_commit.html" title="org.apache.lucene.index.\lIndexCommit" alt="" coords="677,1358,848,1399"/>
<area shape="rect" id="node36" href="../../d6/dab/classorg_1_1apache_1_1lucene_1_1search_1_1similarities_1_1_similarity.html" title="Similarity defines the components of Lucene scoring. " alt="" coords="640,1110,885,1151"/>
<area shape="rect" id="node37" title="The IndexingChain must define the getChain(DocumentsWriterPerThread) method which returns the DocCons..." alt="" coords="624,1241,901,1282"/>
</map>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d71/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_1_1_index_reader_warmer.html">IndexReaderWarmer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="../../df/dfb/classorg_1_1apache_1_1lucene_1_1index_1_1_directory_reader.html#ac7a107c2a70fda71bb38bfdf4606e731">DirectoryReader#open(IndexWriter)</a> has been called (ie, this writer is in near real-time mode), then after a merge completes, this class can be invoked to warm the reader on the newly merged segment, before the merge commits.  <a href="../../d1/d71/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_1_1_index_reader_warmer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19030933712b5c82396bb0a45cf54c53"><td class="memItemLeft" align="right" valign="top">final long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a19030933712b5c82396bb0a45cf54c53">ramBytesUsed</a> ()</td></tr>
<tr class="memdesc:a19030933712b5c82396bb0a45cf54c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory usage of this object in bytes.  <a href="#a19030933712b5c82396bb0a45cf54c53">More...</a><br /></td></tr>
<tr class="separator:a19030933712b5c82396bb0a45cf54c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633b133808f5702f148c98af9be661ab"><td class="memItemLeft" align="right" valign="top"><a id="a633b133808f5702f148c98af9be661ab"></a>
final long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a633b133808f5702f148c98af9be661ab">getFlushingBytes</a> ()</td></tr>
<tr class="memdesc:a633b133808f5702f148c98af9be661ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes currently being flushed. <br /></td></tr>
<tr class="separator:a633b133808f5702f148c98af9be661ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faa3105dec3d21f2d4bb8e50f1e2fce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a2faa3105dec3d21f2d4bb8e50f1e2fce">numDeletedDocs</a> (<a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html">SegmentCommitInfo</a> info)</td></tr>
<tr class="memdesc:a2faa3105dec3d21f2d4bb8e50f1e2fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the number of deleted docs for a pooled reader.  <a href="#a2faa3105dec3d21f2d4bb8e50f1e2fce">More...</a><br /></td></tr>
<tr class="separator:a2faa3105dec3d21f2d4bb8e50f1e2fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c26566b00ba10ba6c5b89ce0f35734"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> (<a class="el" href="../../d3/dcb/classorg_1_1apache_1_1lucene_1_1store_1_1_directory.html">Directory</a> d, <a class="el" href="../../d2/dbd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_config.html">IndexWriterConfig</a> conf)  throws IOException </td></tr>
<tr class="memdesc:a38c26566b00ba10ba6c5b89ce0f35734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> per the settings given in <code>conf</code>.  <a href="#a38c26566b00ba10ba6c5b89ce0f35734">More...</a><br /></td></tr>
<tr class="separator:a38c26566b00ba10ba6c5b89ce0f35734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8de3ed630aedb89ba5d79cc5cf730f"><td class="memItemLeft" align="right" valign="top"><a id="afe8de3ed630aedb89ba5d79cc5cf730f"></a>
<a class="el" href="../../d6/d17/classorg_1_1apache_1_1lucene_1_1index_1_1_live_index_writer_config.html">LiveIndexWriterConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#afe8de3ed630aedb89ba5d79cc5cf730f">getConfig</a> ()</td></tr>
<tr class="memdesc:afe8de3ed630aedb89ba5d79cc5cf730f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="../../d6/d17/classorg_1_1apache_1_1lucene_1_1index_1_1_live_index_writer_config.html">LiveIndexWriterConfig</a>, which can be used to query the <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> current settings, as well as modify "live" ones. <br /></td></tr>
<tr class="separator:afe8de3ed630aedb89ba5d79cc5cf730f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0598be84e163992e0667c7a6ffcc7793"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a0598be84e163992e0667c7a6ffcc7793">close</a> ()  throws IOException </td></tr>
<tr class="memdesc:a0598be84e163992e0667c7a6ffcc7793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes all open resources and releases the write lock.  <a href="#a0598be84e163992e0667c7a6ffcc7793">More...</a><br /></td></tr>
<tr class="separator:a0598be84e163992e0667c7a6ffcc7793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af307e3b9754144535ee4e8772a6bf2fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/dcb/classorg_1_1apache_1_1lucene_1_1store_1_1_directory.html">Directory</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#af307e3b9754144535ee4e8772a6bf2fd">getDirectory</a> ()</td></tr>
<tr class="memdesc:af307e3b9754144535ee4e8772a6bf2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Directory used by this index.  <a href="#af307e3b9754144535ee4e8772a6bf2fd">More...</a><br /></td></tr>
<tr class="separator:af307e3b9754144535ee4e8772a6bf2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0544f5ddf4b2ae78c7a60fbc881301ec"><td class="memItemLeft" align="right" valign="top"><a id="a0544f5ddf4b2ae78c7a60fbc881301ec"></a>
<a class="el" href="../../dd/d43/classorg_1_1apache_1_1lucene_1_1util_1_1_info_stream.html">InfoStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a0544f5ddf4b2ae78c7a60fbc881301ec">getInfoStream</a> ()</td></tr>
<tr class="memdesc:a0544f5ddf4b2ae78c7a60fbc881301ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the info stream that can be used to log messages. <br /></td></tr>
<tr class="separator:a0544f5ddf4b2ae78c7a60fbc881301ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d701a233fa5f828d58d2956389f769d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">Analyzer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a6d701a233fa5f828d58d2956389f769d">getAnalyzer</a> ()</td></tr>
<tr class="memdesc:a6d701a233fa5f828d58d2956389f769d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the analyzer used by this index.  <a href="#a6d701a233fa5f828d58d2956389f769d">More...</a><br /></td></tr>
<tr class="separator:a6d701a233fa5f828d58d2956389f769d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0b7015f1ccc54ce566b352078e0b66"><td class="memItemLeft" align="right" valign="top">synchronized int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aba0b7015f1ccc54ce566b352078e0b66">maxDoc</a> ()</td></tr>
<tr class="memdesc:aba0b7015f1ccc54ce566b352078e0b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), not counting deletions.  <a href="#aba0b7015f1ccc54ce566b352078e0b66">More...</a><br /></td></tr>
<tr class="separator:aba0b7015f1ccc54ce566b352078e0b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e114d1b9d3cc409eec68c17558a8e3f"><td class="memItemLeft" align="right" valign="top">synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a0e114d1b9d3cc409eec68c17558a8e3f">advanceSegmentInfosVersion</a> (long newVersion)</td></tr>
<tr class="memdesc:a0e114d1b9d3cc409eec68c17558a8e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html#a7f48e0163cbaf934b6799fb0482a2af0">SegmentInfos#getVersion</a> is below.  <a href="#a0e114d1b9d3cc409eec68c17558a8e3f">More...</a><br /></td></tr>
<tr class="separator:a0e114d1b9d3cc409eec68c17558a8e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ab37d46bb3c32c302acdedd007c5ef"><td class="memItemLeft" align="right" valign="top">synchronized int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ab0ab37d46bb3c32c302acdedd007c5ef">numDocs</a> ()</td></tr>
<tr class="memdesc:ab0ab37d46bb3c32c302acdedd007c5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), and including deletions.  <a href="#ab0ab37d46bb3c32c302acdedd007c5ef">More...</a><br /></td></tr>
<tr class="separator:ab0ab37d46bb3c32c302acdedd007c5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b6faf5a23c51a4cb44f1cca304ae9f"><td class="memItemLeft" align="right" valign="top">synchronized boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a99b6faf5a23c51a4cb44f1cca304ae9f">hasDeletions</a> ()</td></tr>
<tr class="memdesc:a99b6faf5a23c51a4cb44f1cca304ae9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this index has deletions (including buffered deletions).  <a href="#a99b6faf5a23c51a4cb44f1cca304ae9f">More...</a><br /></td></tr>
<tr class="separator:a99b6faf5a23c51a4cb44f1cca304ae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cafb9ccc02ef802e22a18852d0a8678"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a7cafb9ccc02ef802e22a18852d0a8678">addDocument</a> (Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt; doc)  throws IOException </td></tr>
<tr class="memdesc:a7cafb9ccc02ef802e22a18852d0a8678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a document to this index.  <a href="#a7cafb9ccc02ef802e22a18852d0a8678">More...</a><br /></td></tr>
<tr class="separator:a7cafb9ccc02ef802e22a18852d0a8678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a49f760275bb87b6b64778edce6379"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#af8a49f760275bb87b6b64778edce6379">addDocuments</a> (Iterable&lt;? extends Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&gt; docs)  throws IOException </td></tr>
<tr class="memdesc:af8a49f760275bb87b6b64778edce6379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents.  <a href="#af8a49f760275bb87b6b64778edce6379">More...</a><br /></td></tr>
<tr class="separator:af8a49f760275bb87b6b64778edce6379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa503e296be695e7cbd8efd16cca7edac"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aa503e296be695e7cbd8efd16cca7edac">updateDocuments</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> delTerm, Iterable&lt;? extends Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&gt; docs)  throws IOException </td></tr>
<tr class="memdesc:aa503e296be695e7cbd8efd16cca7edac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically deletes documents matching the provided delTerm and adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents.  <a href="#aa503e296be695e7cbd8efd16cca7edac">More...</a><br /></td></tr>
<tr class="separator:aa503e296be695e7cbd8efd16cca7edac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12972fbd618898ed9e7f8507044de503"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a12972fbd618898ed9e7f8507044de503">softUpdateDocuments</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> term, Iterable&lt;? extends Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&gt; docs, Field... softDeletes)  throws IOException </td></tr>
<tr class="memdesc:a12972fbd618898ed9e7f8507044de503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Atomically updates documents matching the provided term with the given doc-values fields and adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents.  <a href="#a12972fbd618898ed9e7f8507044de503">More...</a><br /></td></tr>
<tr class="separator:a12972fbd618898ed9e7f8507044de503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e27bdf0c81b2daecd7951e49992c4"><td class="memItemLeft" align="right" valign="top">synchronized long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a707e27bdf0c81b2daecd7951e49992c4">tryDeleteDocument</a> (<a class="el" href="../../df/de9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_reader.html">IndexReader</a> readerIn, int docID)  throws IOException </td></tr>
<tr class="memdesc:a707e27bdf0c81b2daecd7951e49992c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: attempts to delete by document ID, as long as the provided reader is a near-real-time reader (from <a class="el" href="../../df/dfb/classorg_1_1apache_1_1lucene_1_1index_1_1_directory_reader.html#ac7a107c2a70fda71bb38bfdf4606e731">DirectoryReader#open(IndexWriter)</a>).  <a href="#a707e27bdf0c81b2daecd7951e49992c4">More...</a><br /></td></tr>
<tr class="separator:a707e27bdf0c81b2daecd7951e49992c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac116c0e5ad5513e442c03e487c7c07c9"><td class="memItemLeft" align="right" valign="top">synchronized long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ac116c0e5ad5513e442c03e487c7c07c9">tryUpdateDocValue</a> (<a class="el" href="../../df/de9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_reader.html">IndexReader</a> readerIn, int docID, Field... fields)  throws IOException </td></tr>
<tr class="memdesc:ac116c0e5ad5513e442c03e487c7c07c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: attempts to update doc values by document ID, as long as the provided reader is a near-real-time reader (from <a class="el" href="../../df/dfb/classorg_1_1apache_1_1lucene_1_1index_1_1_directory_reader.html#ac7a107c2a70fda71bb38bfdf4606e731">DirectoryReader#open(IndexWriter)</a>).  <a href="#ac116c0e5ad5513e442c03e487c7c07c9">More...</a><br /></td></tr>
<tr class="separator:ac116c0e5ad5513e442c03e487c7c07c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748113d653d04e11d80107311f66ee0e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a748113d653d04e11d80107311f66ee0e">deleteDocuments</a> (Term... terms)  throws IOException </td></tr>
<tr class="memdesc:a748113d653d04e11d80107311f66ee0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the document(s) containing any of the terms.  <a href="#a748113d653d04e11d80107311f66ee0e">More...</a><br /></td></tr>
<tr class="separator:a748113d653d04e11d80107311f66ee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1a4dfa5d5d183ae479031a2d73afaf"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a3a1a4dfa5d5d183ae479031a2d73afaf">deleteDocuments</a> (Query... queries)  throws IOException </td></tr>
<tr class="memdesc:a3a1a4dfa5d5d183ae479031a2d73afaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the document(s) matching any of the provided queries.  <a href="#a3a1a4dfa5d5d183ae479031a2d73afaf">More...</a><br /></td></tr>
<tr class="separator:a3a1a4dfa5d5d183ae479031a2d73afaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bb3b6f10588be347ecacaefc960d17"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a36bb3b6f10588be347ecacaefc960d17">updateDocument</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> term, Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt; doc)  throws IOException </td></tr>
<tr class="memdesc:a36bb3b6f10588be347ecacaefc960d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document.  <a href="#a36bb3b6f10588be347ecacaefc960d17">More...</a><br /></td></tr>
<tr class="separator:a36bb3b6f10588be347ecacaefc960d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4657245f3b0f7d35eb02d0260be3523"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ae4657245f3b0f7d35eb02d0260be3523">softUpdateDocument</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> term, Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt; doc, Field... softDeletes)  throws IOException </td></tr>
<tr class="memdesc:ae4657245f3b0f7d35eb02d0260be3523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Updates a document by first updating the document(s) containing <code>term</code> with the given doc-values fields and then adding the new document.  <a href="#ae4657245f3b0f7d35eb02d0260be3523">More...</a><br /></td></tr>
<tr class="separator:ae4657245f3b0f7d35eb02d0260be3523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd7d781c4b8a3c561f0d1581d136c30"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#acfd7d781c4b8a3c561f0d1581d136c30">updateNumericDocValue</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> term, String field, long value)  throws IOException </td></tr>
<tr class="memdesc:acfd7d781c4b8a3c561f0d1581d136c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a document's <a class="el" href="../../dd/d91/classorg_1_1apache_1_1lucene_1_1index_1_1_numeric_doc_values.html">NumericDocValues</a> for <code>field</code> to the given <code>value</code>.  <a href="#acfd7d781c4b8a3c561f0d1581d136c30">More...</a><br /></td></tr>
<tr class="separator:acfd7d781c4b8a3c561f0d1581d136c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4baf547cd2be0ddbbd41b6a8685396e"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aa4baf547cd2be0ddbbd41b6a8685396e">updateBinaryDocValue</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> term, String field, <a class="el" href="../../db/db3/classorg_1_1apache_1_1lucene_1_1util_1_1_bytes_ref.html">BytesRef</a> value)  throws IOException </td></tr>
<tr class="memdesc:aa4baf547cd2be0ddbbd41b6a8685396e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a document's <a class="el" href="../../dc/d40/classorg_1_1apache_1_1lucene_1_1index_1_1_binary_doc_values.html">BinaryDocValues</a> for <code>field</code> to the given <code>value</code>.  <a href="#aa4baf547cd2be0ddbbd41b6a8685396e">More...</a><br /></td></tr>
<tr class="separator:aa4baf547cd2be0ddbbd41b6a8685396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea54ee60f5df1cdaca1769e45728f3a5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aea54ee60f5df1cdaca1769e45728f3a5">updateDocValues</a> (<a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> term, Field... updates)  throws IOException </td></tr>
<tr class="memdesc:aea54ee60f5df1cdaca1769e45728f3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates documents' <a class="el" href="../../d3/d1b/classorg_1_1apache_1_1lucene_1_1index_1_1_doc_values.html" title="This class contains utility methods and constants for DocValues. ">DocValues</a> fields to the given values.  <a href="#aea54ee60f5df1cdaca1769e45728f3a5">More...</a><br /></td></tr>
<tr class="separator:aea54ee60f5df1cdaca1769e45728f3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313d85133bc2a600dd2dc6a70d5b0f38"><td class="memItemLeft" align="right" valign="top">Set&lt; String &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a313d85133bc2a600dd2dc6a70d5b0f38">getFieldNames</a> ()</td></tr>
<tr class="memdesc:a313d85133bc2a600dd2dc6a70d5b0f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unmodifiable set of all field names as visible from this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a>, across all segments of the index.  <a href="#a313d85133bc2a600dd2dc6a70d5b0f38">More...</a><br /></td></tr>
<tr class="separator:a313d85133bc2a600dd2dc6a70d5b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43c2e7d16d5d9e3a41e50a05316f0e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad43c2e7d16d5d9e3a41e50a05316f0e5">forceMerge</a> (int maxNumSegments)  throws IOException </td></tr>
<tr class="memdesc:ad43c2e7d16d5d9e3a41e50a05316f0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces merge policy to merge segments until there are.  <a href="#ad43c2e7d16d5d9e3a41e50a05316f0e5">More...</a><br /></td></tr>
<tr class="separator:ad43c2e7d16d5d9e3a41e50a05316f0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51292f6cdb25fe7b1b8aa73337edd36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a51292f6cdb25fe7b1b8aa73337edd36c">forceMerge</a> (int maxNumSegments, boolean doWait)  throws IOException </td></tr>
<tr class="memdesc:a51292f6cdb25fe7b1b8aa73337edd36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad43c2e7d16d5d9e3a41e50a05316f0e5">forceMerge(int)</a>, except you can specify whether the call should block until all merging completes.  <a href="#a51292f6cdb25fe7b1b8aa73337edd36c">More...</a><br /></td></tr>
<tr class="separator:a51292f6cdb25fe7b1b8aa73337edd36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb9a8fe2787af1d6f1ac17f3e3eee3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#acdb9a8fe2787af1d6f1ac17f3e3eee3e">forceMergeDeletes</a> (boolean doWait)  throws IOException </td></tr>
<tr class="memdesc:acdb9a8fe2787af1d6f1ac17f3e3eee3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a70570e9d106a1e44774401c32e02f005">forceMergeDeletes()</a>, except you can specify whether the call should block until the operation completes.  <a href="#acdb9a8fe2787af1d6f1ac17f3e3eee3e">More...</a><br /></td></tr>
<tr class="separator:acdb9a8fe2787af1d6f1ac17f3e3eee3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70570e9d106a1e44774401c32e02f005"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a70570e9d106a1e44774401c32e02f005">forceMergeDeletes</a> ()  throws IOException </td></tr>
<tr class="memdesc:a70570e9d106a1e44774401c32e02f005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces merging of all segments that have deleted documents.  <a href="#a70570e9d106a1e44774401c32e02f005">More...</a><br /></td></tr>
<tr class="separator:a70570e9d106a1e44774401c32e02f005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259c8826984a7feb988a51328f00cb60"><td class="memItemLeft" align="right" valign="top">final void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a259c8826984a7feb988a51328f00cb60">maybeMerge</a> ()  throws IOException </td></tr>
<tr class="memdesc:a259c8826984a7feb988a51328f00cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merges and then iterate (test again if merges are needed) until no more merges are returned by the mergePolicy.  <a href="#a259c8826984a7feb988a51328f00cb60">More...</a><br /></td></tr>
<tr class="separator:a259c8826984a7feb988a51328f00cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdab41dabb53342b69614ad3796ae4b6"><td class="memItemLeft" align="right" valign="top">synchronized Set&lt; <a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html">SegmentCommitInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#acdab41dabb53342b69614ad3796ae4b6">getMergingSegments</a> ()</td></tr>
<tr class="memdesc:acdab41dabb53342b69614ad3796ae4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: to be used by a <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a> to avoid selecting merges for segments already being merged.  <a href="#acdab41dabb53342b69614ad3796ae4b6">More...</a><br /></td></tr>
<tr class="separator:acdab41dabb53342b69614ad3796ae4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6448ddeddb776d02fbfa77aeb763f78e"><td class="memItemLeft" align="right" valign="top">synchronized MergePolicy.OneMerge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a6448ddeddb776d02fbfa77aeb763f78e">getNextMerge</a> ()</td></tr>
<tr class="memdesc:a6448ddeddb776d02fbfa77aeb763f78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: the <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a> calls this method to retrieve the next merge requested by the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a>.  <a href="#a6448ddeddb776d02fbfa77aeb763f78e">More...</a><br /></td></tr>
<tr class="separator:a6448ddeddb776d02fbfa77aeb763f78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76873f159270ebcbb7157a935ea71bd"><td class="memItemLeft" align="right" valign="top">synchronized boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ae76873f159270ebcbb7157a935ea71bd">hasPendingMerges</a> ()</td></tr>
<tr class="memdesc:ae76873f159270ebcbb7157a935ea71bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: returns true if there are merges waiting to be scheduled.  <a href="#ae76873f159270ebcbb7157a935ea71bd">More...</a><br /></td></tr>
<tr class="separator:ae76873f159270ebcbb7157a935ea71bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ba70af74683a8c7d8f2b4527f8b41b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aa7ba70af74683a8c7d8f2b4527f8b41b">rollback</a> ()  throws IOException </td></tr>
<tr class="memdesc:aa7ba70af74683a8c7d8f2b4527f8b41b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> without committing any changes that have occurred since the last commit (or since it was opened, if commit hasn't been called).  <a href="#aa7ba70af74683a8c7d8f2b4527f8b41b">More...</a><br /></td></tr>
<tr class="separator:aa7ba70af74683a8c7d8f2b4527f8b41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4721e74766499fa7a1da53881e7b60"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ade4721e74766499fa7a1da53881e7b60">deleteAll</a> ()  throws IOException </td></tr>
<tr class="memdesc:ade4721e74766499fa7a1da53881e7b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all documents in the index.  <a href="#ade4721e74766499fa7a1da53881e7b60">More...</a><br /></td></tr>
<tr class="separator:ade4721e74766499fa7a1da53881e7b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e7741dfff10bc13c7417e745ea23d0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad8e7741dfff10bc13c7417e745ea23d0">addIndexes</a> (Directory... dirs)  throws IOException </td></tr>
<tr class="memdesc:ad8e7741dfff10bc13c7417e745ea23d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all segments from an array of indexes into this index.  <a href="#ad8e7741dfff10bc13c7417e745ea23d0">More...</a><br /></td></tr>
<tr class="separator:ad8e7741dfff10bc13c7417e745ea23d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b331858b495e50f6bd7ab2916ab6c0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a98b331858b495e50f6bd7ab2916ab6c0">addIndexes</a> (CodecReader... readers)  throws IOException </td></tr>
<tr class="memdesc:a98b331858b495e50f6bd7ab2916ab6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the provided indexes into this index.  <a href="#a98b331858b495e50f6bd7ab2916ab6c0">More...</a><br /></td></tr>
<tr class="separator:a98b331858b495e50f6bd7ab2916ab6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fe1cca1e61c4e749d72e7c9918540a"><td class="memItemLeft" align="right" valign="top">final long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a43fe1cca1e61c4e749d72e7c9918540a">prepareCommit</a> ()  throws IOException </td></tr>
<tr class="separator:a43fe1cca1e61c4e749d72e7c9918540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ec85d7a69ecf96994f8d2186561a0d"><td class="memItemLeft" align="right" valign="top">final boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38ec85d7a69ecf96994f8d2186561a0d">flushNextBuffer</a> ()  throws IOException </td></tr>
<tr class="separator:a38ec85d7a69ecf96994f8d2186561a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ce5f1d9dbf1a524d725b3643c73a32"><td class="memItemLeft" align="right" valign="top">final synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a57ce5f1d9dbf1a524d725b3643c73a32">setLiveCommitData</a> (Iterable&lt; Map.Entry&lt; String, String &gt;&gt; commitUserData)</td></tr>
<tr class="memdesc:a57ce5f1d9dbf1a524d725b3643c73a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to provide the commit user data map at commit time.  <a href="#a57ce5f1d9dbf1a524d725b3643c73a32">More...</a><br /></td></tr>
<tr class="separator:a57ce5f1d9dbf1a524d725b3643c73a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532a7ede6e3225d97c28fe5e0afc09e9"><td class="memItemLeft" align="right" valign="top">final synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a532a7ede6e3225d97c28fe5e0afc09e9">setLiveCommitData</a> (Iterable&lt; Map.Entry&lt; String, String &gt;&gt; commitUserData, boolean doIncrementVersion)</td></tr>
<tr class="memdesc:a532a7ede6e3225d97c28fe5e0afc09e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the commit user data iterator, controlling whether to advance the <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html#a7f48e0163cbaf934b6799fb0482a2af0">SegmentInfos#getVersion</a>.  <a href="#a532a7ede6e3225d97c28fe5e0afc09e9">More...</a><br /></td></tr>
<tr class="separator:a532a7ede6e3225d97c28fe5e0afc09e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd51d33169b97b261dbce4a012f5d74"><td class="memItemLeft" align="right" valign="top"><a id="a1dd51d33169b97b261dbce4a012f5d74"></a>
final synchronized Iterable&lt; Map.Entry&lt; String, String &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a1dd51d33169b97b261dbce4a012f5d74">getLiveCommitData</a> ()</td></tr>
<tr class="memdesc:a1dd51d33169b97b261dbce4a012f5d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the commit user data iterable previously set with <a class="el" href="../../">setLiveCommitData(Iterable)</a>, or null if nothing has been set yet. <br /></td></tr>
<tr class="separator:a1dd51d33169b97b261dbce4a012f5d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b235328bc02558089135f219ac9a01"><td class="memItemLeft" align="right" valign="top">final long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit</a> ()  throws IOException </td></tr>
<tr class="separator:a09b235328bc02558089135f219ac9a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab873511dc8d59658722b1303f6f513aa"><td class="memItemLeft" align="right" valign="top">final boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ab873511dc8d59658722b1303f6f513aa">hasUncommittedChanges</a> ()</td></tr>
<tr class="memdesc:ab873511dc8d59658722b1303f6f513aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there may be changes that have not been committed.  <a href="#ab873511dc8d59658722b1303f6f513aa">More...</a><br /></td></tr>
<tr class="separator:ab873511dc8d59658722b1303f6f513aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d48a48833afff4cb4819b12e498e6e"><td class="memItemLeft" align="right" valign="top">final void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a36d48a48833afff4cb4819b12e498e6e">flush</a> ()  throws IOException </td></tr>
<tr class="memdesc:a36d48a48833afff4cb4819b12e498e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all in-memory segments to the <a class="el" href="../../">Directory</a>, but does not commit (fsync) them (call <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit</a> for that).  <a href="#a36d48a48833afff4cb4819b12e498e6e">More...</a><br /></td></tr>
<tr class="separator:a36d48a48833afff4cb4819b12e498e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718325dc0f31bae2936b222c3f8c71c"><td class="memItemLeft" align="right" valign="top">final synchronized int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a7718325dc0f31bae2936b222c3f8c71c">numRamDocs</a> ()</td></tr>
<tr class="memdesc:a7718325dc0f31bae2936b222c3f8c71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: Return the number of documents currently buffered in RAM.  <a href="#a7718325dc0f31bae2936b222c3f8c71c">More...</a><br /></td></tr>
<tr class="separator:a7718325dc0f31bae2936b222c3f8c71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e4c4638add0e7631a3966d79ec81ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a96e4c4638add0e7631a3966d79ec81ee">merge</a> (MergePolicy.OneMerge merge)  throws IOException </td></tr>
<tr class="memdesc:a96e4c4638add0e7631a3966d79ec81ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the indicated segments, replacing them in the stack with a single segment.  <a href="#a96e4c4638add0e7631a3966d79ec81ee">More...</a><br /></td></tr>
<tr class="separator:a96e4c4638add0e7631a3966d79ec81ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5523c93b54c2bc4eb6eb061c28ac9404"><td class="memItemLeft" align="right" valign="top">Throwable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a5523c93b54c2bc4eb6eb061c28ac9404">getTragicException</a> ()</td></tr>
<tr class="memdesc:a5523c93b54c2bc4eb6eb061c28ac9404"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this.  <a href="#a5523c93b54c2bc4eb6eb061c28ac9404">More...</a><br /></td></tr>
<tr class="separator:a5523c93b54c2bc4eb6eb061c28ac9404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca35630ce6ee092afe56ab4be3d9079"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a8ca35630ce6ee092afe56ab4be3d9079">isOpen</a> ()</td></tr>
<tr class="memdesc:a8ca35630ce6ee092afe56ab4be3d9079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns.  <a href="#a8ca35630ce6ee092afe56ab4be3d9079">More...</a><br /></td></tr>
<tr class="separator:a8ca35630ce6ee092afe56ab4be3d9079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbceb644a4a164f0308e3b074a57a60"><td class="memItemLeft" align="right" valign="top">synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a2fbceb644a4a164f0308e3b074a57a60">deleteUnusedFiles</a> ()  throws IOException </td></tr>
<tr class="memdesc:a2fbceb644a4a164f0308e3b074a57a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expert: remove any index files that are no longer used.  <a href="#a2fbceb644a4a164f0308e3b074a57a60">More...</a><br /></td></tr>
<tr class="separator:a2fbceb644a4a164f0308e3b074a57a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9cd3ff1819e51d456a40537bca5a5f"><td class="memItemLeft" align="right" valign="top">synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a9a9cd3ff1819e51d456a40537bca5a5f">incRefDeleter</a> (<a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a> segmentInfos)  throws IOException </td></tr>
<tr class="memdesc:a9a9cd3ff1819e51d456a40537bca5a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that the files referenced by this <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a> are still in use.  <a href="#a9a9cd3ff1819e51d456a40537bca5a5f">More...</a><br /></td></tr>
<tr class="separator:a9a9cd3ff1819e51d456a40537bca5a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4c1d7e8169e14c846fe6b46b1f579d"><td class="memItemLeft" align="right" valign="top">synchronized void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a5b4c1d7e8169e14c846fe6b46b1f579d">decRefDeleter</a> (<a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a> segmentInfos)  throws IOException </td></tr>
<tr class="memdesc:a5b4c1d7e8169e14c846fe6b46b1f579d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record that the files referenced by this <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a> are no longer in use.  <a href="#a5b4c1d7e8169e14c846fe6b46b1f579d">More...</a><br /></td></tr>
<tr class="separator:a5b4c1d7e8169e14c846fe6b46b1f579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808812c144444de2c277ea4b8147194c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a808812c144444de2c277ea4b8147194c">getMaxCompletedSequenceNumber</a> ()</td></tr>
<tr class="memdesc:a808812c144444de2c277ea4b8147194c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the highest <a href="../../#sequence_number">sequence number</a> across all completed operations, or 0 if no operations have finished yet.  <a href="#a808812c144444de2c277ea4b8147194c">More...</a><br /></td></tr>
<tr class="separator:a808812c144444de2c277ea4b8147194c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4507676a73a0274b3f36cbacdcf63e"><td class="memItemLeft" align="right" valign="top">final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#acb4507676a73a0274b3f36cbacdcf63e">numDeletesToMerge</a> (<a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html">SegmentCommitInfo</a> info)  throws IOException </td></tr>
<tr class="memdesc:acb4507676a73a0274b3f36cbacdcf63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of deletes a merge would claim back if the given segment is merged.  <a href="#acb4507676a73a0274b3f36cbacdcf63e">More...</a><br /></td></tr>
<tr class="separator:acb4507676a73a0274b3f36cbacdcf63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html">org.apache.lucene.util.Accountable</a></td></tr>
<tr class="memitem:aaee876773cafc6f7ebe703baa5abc3cc inherit pub_methods_interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable"><td class="memItemLeft" align="right" valign="top">default Collection&lt; <a class="el" href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html">Accountable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html#aaee876773cafc6f7ebe703baa5abc3cc">getChildResources</a> ()</td></tr>
<tr class="memdesc:aaee876773cafc6f7ebe703baa5abc3cc inherit pub_methods_interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns nested resources of this class.  <a href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html#aaee876773cafc6f7ebe703baa5abc3cc">More...</a><br /></td></tr>
<tr class="separator:aaee876773cafc6f7ebe703baa5abc3cc inherit pub_methods_interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:af267b45e57b9fd6d15964b1e22fdd35d"><td class="memItemLeft" align="right" valign="top">static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#af267b45e57b9fd6d15964b1e22fdd35d">MAX_DOCS</a> = Integer.MAX_VALUE - 128</td></tr>
<tr class="memdesc:af267b45e57b9fd6d15964b1e22fdd35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hard limit on maximum number of documents that may be added to the index.  <a href="#af267b45e57b9fd6d15964b1e22fdd35d">More...</a><br /></td></tr>
<tr class="separator:af267b45e57b9fd6d15964b1e22fdd35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a5e2920fe8656d139dd9de1e874bad"><td class="memItemLeft" align="right" valign="top">static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a86a5e2920fe8656d139dd9de1e874bad">MAX_POSITION</a> = Integer.MAX_VALUE - 128</td></tr>
<tr class="memdesc:a86a5e2920fe8656d139dd9de1e874bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value of the token position in an indexed field.  <a href="#a86a5e2920fe8656d139dd9de1e874bad">More...</a><br /></td></tr>
<tr class="separator:a86a5e2920fe8656d139dd9de1e874bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4ad5e2acf60ed03425b80aec6444a9"><td class="memItemLeft" align="right" valign="top"><a id="acb4ad5e2acf60ed03425b80aec6444a9"></a>
static final String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#acb4ad5e2acf60ed03425b80aec6444a9">WRITE_LOCK_NAME</a> = &quot;write.lock&quot;</td></tr>
<tr class="memdesc:acb4ad5e2acf60ed03425b80aec6444a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the write lock in the index. <br /></td></tr>
<tr class="separator:acb4ad5e2acf60ed03425b80aec6444a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc345a1fdc69cde2c9959422098ba52"><td class="memItemLeft" align="right" valign="top">static final String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a4cc345a1fdc69cde2c9959422098ba52">SOURCE</a> = &quot;source&quot;</td></tr>
<tr class="memdesc:a4cc345a1fdc69cde2c9959422098ba52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key for the source of a segment in the <a class="el" href="../../d2/d9b/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_info.html#a446c10af6e5180377b6518137887d507">diagnostics</a>.  <a href="#a4cc345a1fdc69cde2c9959422098ba52">More...</a><br /></td></tr>
<tr class="separator:a4cc345a1fdc69cde2c9959422098ba52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4e46c2b99551a3ed9439d25d3dafdc"><td class="memItemLeft" align="right" valign="top">static final String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a3a4e46c2b99551a3ed9439d25d3dafdc">SOURCE_MERGE</a> = &quot;merge&quot;</td></tr>
<tr class="memdesc:a3a4e46c2b99551a3ed9439d25d3dafdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of a segment which results from a merge of other segments.  <a href="#a3a4e46c2b99551a3ed9439d25d3dafdc">More...</a><br /></td></tr>
<tr class="separator:a3a4e46c2b99551a3ed9439d25d3dafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d27aea5fb559a8009584cb155ceaea"><td class="memItemLeft" align="right" valign="top">static final String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a54d27aea5fb559a8009584cb155ceaea">SOURCE_FLUSH</a> = &quot;flush&quot;</td></tr>
<tr class="memdesc:a54d27aea5fb559a8009584cb155ceaea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of a segment which results from a flush.  <a href="#a54d27aea5fb559a8009584cb155ceaea">More...</a><br /></td></tr>
<tr class="separator:a54d27aea5fb559a8009584cb155ceaea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f0feed7029ba6a2ffd5e533923f317"><td class="memItemLeft" align="right" valign="top">static final String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#af3f0feed7029ba6a2ffd5e533923f317">SOURCE_ADDINDEXES_READERS</a> = &quot;addIndexes(CodecReader...)&quot;</td></tr>
<tr class="memdesc:af3f0feed7029ba6a2ffd5e533923f317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of a segment which results from a call to <a class="el" href="../../">addIndexes(CodecReader...)</a>.  <a href="#af3f0feed7029ba6a2ffd5e533923f317">More...</a><br /></td></tr>
<tr class="separator:af3f0feed7029ba6a2ffd5e533923f317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06d12ac1b83b91808a2715bc3ac121"><td class="memItemLeft" align="right" valign="top">static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#afd06d12ac1b83b91808a2715bc3ac121">MAX_TERM_LENGTH</a> = DocumentsWriterPerThread.MAX_TERM_LENGTH_UTF8</td></tr>
<tr class="memdesc:afd06d12ac1b83b91808a2715bc3ac121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute hard maximum length for a term, in bytes once encoded as UTF8.  <a href="#afd06d12ac1b83b91808a2715bc3ac121">More...</a><br /></td></tr>
<tr class="separator:afd06d12ac1b83b91808a2715bc3ac121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40b71d23264080e96da4407d9a74156"><td class="memItemLeft" align="right" valign="top"><a id="aa40b71d23264080e96da4407d9a74156"></a>
static final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aa40b71d23264080e96da4407d9a74156">MAX_STORED_STRING_LENGTH</a> = <a class="el" href="../../de/d47/classorg_1_1apache_1_1lucene_1_1util_1_1_array_util.html#a108b9786f0f9a9ff01ee5dc958a1f67c">ArrayUtil.MAX_ARRAY_LENGTH</a> / <a class="el" href="../../dc/dee/classorg_1_1apache_1_1lucene_1_1util_1_1_unicode_util.html#a17c00ec4bc2b2a009da2d627a9ead481">UnicodeUtil.MAX_UTF8_BYTES_PER_CHAR</a></td></tr>
<tr class="memdesc:aa40b71d23264080e96da4407d9a74156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length string for a stored field. <br /></td></tr>
<tr class="separator:aa40b71d23264080e96da4407d9a74156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae78ca58f57b4beaa80306cbfbb0654ee"><td class="memItemLeft" align="right" valign="top">final void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ae78ca58f57b4beaa80306cbfbb0654ee">ensureOpen</a> (boolean failIfClosing)  throws AlreadyClosedException </td></tr>
<tr class="memdesc:ae78ca58f57b4beaa80306cbfbb0654ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to throw an <a class="el" href="../../">AlreadyClosedException</a> if this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> has been closed or is in the process of closing.  <a href="#ae78ca58f57b4beaa80306cbfbb0654ee">More...</a><br /></td></tr>
<tr class="separator:ae78ca58f57b4beaa80306cbfbb0654ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c5781d3e3dbcccd5182e90db20f175"><td class="memItemLeft" align="right" valign="top">final void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a72c5781d3e3dbcccd5182e90db20f175">ensureOpen</a> ()  throws AlreadyClosedException </td></tr>
<tr class="memdesc:a72c5781d3e3dbcccd5182e90db20f175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to throw an <a class="el" href="../../">AlreadyClosedException</a> if this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> has been closed (.  <a href="#a72c5781d3e3dbcccd5182e90db20f175">More...</a><br /></td></tr>
<tr class="separator:a72c5781d3e3dbcccd5182e90db20f175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a56da365bc605a1aabd8f06d1cded87"><td class="memItemLeft" align="right" valign="top"><a id="a9a56da365bc605a1aabd8f06d1cded87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a9a56da365bc605a1aabd8f06d1cded87">doAfterFlush</a> ()  throws IOException </td></tr>
<tr class="memdesc:a9a56da365bc605a1aabd8f06d1cded87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hook for extending classes to execute operations after pending added and deleted documents have been flushed to the Directory but before the change is committed (new segments_N file written). <br /></td></tr>
<tr class="separator:a9a56da365bc605a1aabd8f06d1cded87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0487347e183a7a7a974ff5bd19842fa6"><td class="memItemLeft" align="right" valign="top"><a id="a0487347e183a7a7a974ff5bd19842fa6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a0487347e183a7a7a974ff5bd19842fa6">doBeforeFlush</a> ()  throws IOException </td></tr>
<tr class="memdesc:a0487347e183a7a7a974ff5bd19842fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hook for extending classes to execute operations before pending added and deleted documents are flushed to the Directory. <br /></td></tr>
<tr class="separator:a0487347e183a7a7a974ff5bd19842fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fab00c579190f6a5144f99c3ec8bed"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a01fab00c579190f6a5144f99c3ec8bed">isEnableTestPoints</a> ()</td></tr>
<tr class="memdesc:a01fab00c579190f6a5144f99c3ec8bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests should override this to enable test points.  <a href="#a01fab00c579190f6a5144f99c3ec8bed">More...</a><br /></td></tr>
<tr class="separator:a01fab00c579190f6a5144f99c3ec8bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> creates and maintains an index. </p>
<p>The <a class="el" href="../../">OpenMode</a> option on <a class="el" href="../../d2/dbd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_config.html#a9a272e92c2d5fbd14632978dff519003">IndexWriterConfig#setOpenMode(OpenMode)</a> determines whether a new index is created, or whether an existing index is opened. Note that you can open an index with <a class="el" href="../../">OpenMode#CREATE</a> even while readers are using the index. The old readers will continue to search the "point in time" snapshot they had opened, and won't see the newly created index until they re-open. If <a class="el" href="../../">OpenMode#CREATE_OR_APPEND</a> is used <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> will create a new index if there is not already an index at the provided path and otherwise open the existing index.</p>
<p>In either case, documents are added with <a class="el" href="../../">addDocument</a> and removed with <a class="el" href="../../">deleteDocuments(Term...)</a> or <a class="el" href="../../">deleteDocuments(Query...)</a>. A document can be updated with <a class="el" href="../../">updateDocument</a> (which just deletes and then adds the entire document). When finished adding, deleting and updating documents, <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a0598be84e163992e0667c7a6ffcc7793">close</a> should be called.</p>
<p><a class="anchor" id="sequence_numbers"></a> </p>
<p>Each method that changes the index returns a</p><div class="fragment"><div class="line"><span class="keywordtype">long</span> </div></div><!-- fragment --><p> sequence number, which expresses the effective order in which each change was applied. <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit</a> also returns a sequence number, describing which changes are in the commit point and which are not. Sequence numbers are transient (not saved into the index in any way) and only valid within a single</p><div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --><p> instance.</p>
<p><a class="anchor" id="flush"></a> </p>
<p>These changes are buffered in memory and periodically flushed to the <a class="el" href="../../">Directory</a> (during the above method calls). A flush is triggered when there are enough added documents since the last flush. Flushing is triggered either by RAM usage of the documents (see <a class="el" href="../../">IndexWriterConfig#setRAMBufferSizeMB</a>) or the number of added documents (see <a class="el" href="../../">IndexWriterConfig#setMaxBufferedDocs(int)</a>). The default is to flush when RAM usage hits <a class="el" href="../../d2/dbd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_config.html#a2a17dafd9d469fce5e8d482f8f9d6ffe">IndexWriterConfig#DEFAULT_RAM_BUFFER_SIZE_MB</a> MB. For best indexing speed you should flush by RAM usage with a large RAM buffer. In contrast to the other flush options <a class="el" href="../../">IndexWriterConfig#setRAMBufferSizeMB</a> and <a class="el" href="../../">IndexWriterConfig#setMaxBufferedDocs(int)</a>, deleted terms won't trigger a segment flush. Note that flushing just moves the internal buffered state in <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> into the index, but these changes are not visible to <a class="el" href="../../df/de9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_reader.html" title=" IndexReader is an abstract class, providing an interface for accessing a point-in-time view of an in...">IndexReader</a> until either <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> or <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a0598be84e163992e0667c7a6ffcc7793">close</a> is called. A flush may also trigger one or more segment merges which by default run with a background thread so as not to block the addDocument calls (see <a href="../../#mergePolicy">below</a> for changing the <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a>).</p>
<p>Opening an <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> creates a lock file for the directory in use. Trying to open another <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> on the same directory will lead to a <a class="el" href="../../">LockObtainFailedException</a>.</p>
<p><a class="anchor" id="deletionPolicy"></a> </p>
<p>Expert: <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> allows an optional <a class="el" href="../../d8/dcd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a> implementation to be specified. You can use this to control when prior commits are deleted from the index. The default policy is <a class="el" href="../../da/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_keep_only_last_commit_deletion_policy.html">KeepOnlyLastCommitDeletionPolicy</a> which removes all prior commits as soon as a new commit is done. Creating your own policy can allow you to explicitly keep previous "point in time" commits alive in the index for some time, either because this is useful for your application, or to give readers enough time to refresh to the new commit without having the old commit deleted out from under them. The latter is necessary when multiple computers take turns opening their own</p><div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">IndexReader </div></div><!-- fragment --><p> s against a single shared index mounted via remote filesystems like NFS which do not support "delete on last close" semantics. A single computer accessing an index via NFS is fine with the default deletion policy since NFS clients emulate "delete on
last close" locally. That said, accessing an index via NFS will likely result in poor performance compared to a local IO device. </p>
<p><a class="anchor" id="mergePolicy"></a> </p>
<p>Expert: <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> allows you to separately change the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a> and the <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a>. The <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a> is invoked whenever there are changes to the segments in the index. Its role is to select which merges to do, if any, and return a <a class="el" href="../../">MergePolicy.MergeSpecification</a> describing the merges. The default is <a class="el" href="../../d6/d60/classorg_1_1apache_1_1lucene_1_1index_1_1_log_byte_size_merge_policy.html">LogByteSizeMergePolicy</a>. Then, the <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a> is invoked with the requested merges and it decides when and how to run the merges. The default is <a class="el" href="../../d3/d57/classorg_1_1apache_1_1lucene_1_1index_1_1_concurrent_merge_scheduler.html">ConcurrentMergeScheduler</a>. </p>
<p><a class="anchor" id="OOME"></a></p>
<p><b>NOTE</b>: if you hit a VirtualMachineError, or disaster strikes during a checkpoint then <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> will close itself. This is a defensive measure in case any internal state (buffered documents, deletions, reference counts) were corrupted. <br />
Any subsequent calls will throw an AlreadyClosedException.</p>
<p><a class="anchor" id="thread-safety"></a></p>
<p><b>NOTE</b>: <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html">IndexWriter</a> instances are completely thread safe, meaning multiple threads can call any of its methods, concurrently. If your application requires external synchronization, you should <b>not</b> synchronize on the <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> instance as this may cause deadlock; use your own (non-Lucene) objects instead. </p>
<p><b>NOTE</b>: If you call <code>Thread.interrupt()</code> on a thread that's within <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a>, <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> will try to catch this (eg, if it's in a wait() or Thread.sleep()), and will then throw the unchecked exception <a class="el" href="../../">ThreadInterruptedException</a> and <b>clear</b> the interrupt status on the thread.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a38c26566b00ba10ba6c5b89ce0f35734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c26566b00ba10ba6c5b89ce0f35734">&#9670;&nbsp;</a></span>IndexWriter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.apache.lucene.index.IndexWriter.IndexWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dcb/classorg_1_1apache_1_1lucene_1_1store_1_1_directory.html">Directory</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/dbd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_config.html">IndexWriterConfig</a>&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> per the settings given in <code>conf</code>. </p>
<p>If you want to make "live" changes to this writer instance, use <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#afe8de3ed630aedb89ba5d79cc5cf730f">getConfig()</a>.</p>
<p><b>NOTE:</b> after ths writer is created, the given configuration instance cannot be passed to another writer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>the index directory. The index is either created or appended according <code>conf.getOpenMode()</code>. </td></tr>
    <tr><td class="paramname">conf</td><td>the configuration settings according to which <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> should be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if the directory cannot be read/written to, or if it does not exist and <code>conf.getOpenMode()</code> is <code>OpenMode.APPEND</code> or if there is any other low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7cafb9ccc02ef802e22a18852d0a8678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cafb9ccc02ef802e22a18852d0a8678">&#9670;&nbsp;</a></span>addDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.addDocument </td>
          <td>(</td>
          <td class="paramtype">Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&#160;</td>
          <td class="paramname"><em>doc</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a document to this index. </p>
<p>Note that if an Exception is hit (for example disk full) then the index will be consistent, but this document may not have been added. Furthermore, it's possible the index will have one segment in non-compound format even when using compound files (when a merge has partially succeeded).</p>
<p>This method periodically flushes pending documents to the Directory (see <a href="../../#flush">above</a>), and also periodically triggers segment merges in the index according to the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a> in use.</p>
<p>Merges temporarily consume space in the directory. The amount of space required is up to 1X the size of all segments being merged, when no readers/searchers are open against the index, and up to 2X the size of all segments being merged when readers/searchers are open against the index (see <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad43c2e7d16d5d9e3a41e50a05316f0e5">forceMerge(int)</a> for details). The sequence of primitive merge operations performed is governed by the merge policy.</p>
<p>Note that each term in the document can be no longer than <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#afd06d12ac1b83b91808a2715bc3ac121">MAX_TERM_LENGTH</a> in bytes, otherwise an IllegalArgumentException will be thrown.</p>
<p>Note that it's possible to create an invalid Unicode string in java if a UTF16 surrogate pair is malformed. In this case, the invalid characters are silently replaced with the Unicode replacement character U+FFFD.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a49f760275bb87b6b64778edce6379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a49f760275bb87b6b64778edce6379">&#9670;&nbsp;</a></span>addDocuments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.addDocuments </td>
          <td>(</td>
          <td class="paramtype">Iterable&lt;? extends Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>docs</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents. </p>
<p><b>WARNING</b>: the index does not currently record which documents were added as a block. Today this is fine, because merging will preserve a block. The order of documents within a segment will be preserved, even when child documents within a block are deleted. Most search features (like result grouping and block joining) require you to mark documents; when these documents are deleted these search features will not work as expected. Obviously adding documents to an existing block will require you the reindex the entire block.</p>
<p>However it's possible that in the future Lucene may merge more aggressively re-order documents (for example, perhaps to obtain better index compression), in which case you may need to fully re-index your documents at that time.</p>
<p>See <a class="el" href="../../">addDocument(Iterable)</a> for details on index and <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> state after an Exception, and flushing/merging temporary free space requirements.</p>
<p><b>NOTE</b>: tools that do offline splitting of an index (for example, IndexSplitter in contrib) or re-sorting of documents (for example, IndexSorter in contrib) are not aware of these atomically added documents and will likely break them up. Use such tools at your own risk!</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error</td></tr>
  </table>
  </dd>
</dl>
<p>.experimental </p>

</div>
</div>
<a id="ad8e7741dfff10bc13c7417e745ea23d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e7741dfff10bc13c7417e745ea23d0">&#9670;&nbsp;</a></span>addIndexes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.addIndexes </td>
          <td>(</td>
          <td class="paramtype">Directory...&#160;</td>
          <td class="paramname"><em>dirs</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds all segments from an array of indexes into this index. </p>
<p>This may be used to parallelize batch indexing. A large document collection can be broken into sub-collections. Each sub-collection can be indexed in parallel, on a different thread, process or machine. The complete index can then be created by merging sub-collection indexes with this method.</p>
<p><b>NOTE:</b> this method acquires the write lock in each directory, to ensure that no</p><div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --><p> is currently open or tries to open while this is running.</p>
<p>This method is transactional in how Exceptions are handled: it does not commit a new segments_N file until all indexes are added. This means if an Exception occurs (for example disk full), then either no indexes will have been added or they all will have been.</p>
<p>Note that this requires temporary free space in the <a class="el" href="../../">Directory</a> up to 2X the sum of all input indexes (including the starting index). If readers/searchers are open against the starting index, then temporary free space required will be higher by the size of the starting index (see <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad43c2e7d16d5d9e3a41e50a05316f0e5">forceMerge(int)</a> for details).</p>
<p>This requires this index not be among those to be added.</p>
<p>All added indexes must have been created by the same Lucene version as this index.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if addIndexes would cause the index to exceed <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#af267b45e57b9fd6d15964b1e22fdd35d">MAX_DOCS</a>, or if the indoming index sort does not match this index's index sort </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98b331858b495e50f6bd7ab2916ab6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b331858b495e50f6bd7ab2916ab6c0">&#9670;&nbsp;</a></span>addIndexes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.addIndexes </td>
          <td>(</td>
          <td class="paramtype">CodecReader...&#160;</td>
          <td class="paramname"><em>readers</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the provided indexes into this index. </p>
<p>The provided IndexReaders are not closed.</p>
<p>See <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad8e7741dfff10bc13c7417e745ea23d0">addIndexes</a> for details on transactional semantics, temporary free space required in the Directory, and non-CFS segments on an Exception.</p>
<p><b>NOTE:</b> empty segments are dropped by this method and not added to this index.</p>
<p><b>NOTE:</b> this merges all given <a class="el" href="../../dd/dd2/classorg_1_1apache_1_1lucene_1_1index_1_1_leaf_reader.html">LeafReader</a>s in one merge. If you intend to merge a large number of readers, it may be better to call this method multiple times, each time with a small set of readers. In principle, if you use a merge policy with a</p><div class="fragment"><div class="line">mergeFactor </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">maxMergeAtOnce </div></div><!-- fragment --><p> parameter, you should pass that many readers in one call.</p>
<p><b>NOTE:</b> this method does not call or make use of the <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a>, so any custom bandwidth throttling is at the moment ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if addIndexes would cause the index to exceed <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#af267b45e57b9fd6d15964b1e22fdd35d">MAX_DOCS</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e114d1b9d3cc409eec68c17558a8e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e114d1b9d3cc409eec68c17558a8e3f">&#9670;&nbsp;</a></span>advanceSegmentInfosVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.apache.lucene.index.IndexWriter.advanceSegmentInfosVersion </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>newVersion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html#a7f48e0163cbaf934b6799fb0482a2af0">SegmentInfos#getVersion</a> is below. </p>
<div class="fragment"><div class="line">newVersion </div></div><!-- fragment --><p> then update it to this value.</p>
<p>.internal </p>

</div>
</div>
<a id="a0598be84e163992e0667c7a6ffcc7793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0598be84e163992e0667c7a6ffcc7793">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes all open resources and releases the write lock. </p>
<p>If <a class="el" href="../../d6/d17/classorg_1_1apache_1_1lucene_1_1index_1_1_live_index_writer_config.html#a886ab15da04a1b3ea55e5b431469bf42">IndexWriterConfig#commitOnClose</a> is <code>true</code>, this will attempt to gracefully shut down by writing any changes, waiting for any running merges, committing, and closing. In this case, note that: </p><ul>
<li>
If you called prepareCommit but failed to call commit, this method will throw<div class="fragment"><div class="line">IllegalStateException </div></div><!-- fragment --> and the<div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --> will not be closed. </li>
<li>
If this method throws any other exception, the<div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --> will be closed, but changes may have been lost. </li>
</ul>
<p>Note that this may be a costly operation, so, try to re-use a single writer instead of closing and opening a new one. See <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> for caveats about write caching done by some IO devices.</p>
<p><b>NOTE</b>: You must ensure no other threads are still making changes at the same time that this method is invoked.</p>

</div>
</div>
<a id="a09b235328bc02558089135f219ac9a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b235328bc02558089135f219ac9a01">&#9670;&nbsp;</a></span>commit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final long org.apache.lucene.index.IndexWriter.commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits all pending changes (added and deleted documents, segment merges, added indexes, etc.) to the index, and syncs all referenced index files, such that a reader will see the changes and the index updates will survive an OS or machine crash or power loss. Note that this does not wait for any running background merges to finish. This may be a costly operation, so you should test the cost in your application and do it only when really necessary.</p>
<p>Note that this operation calls <a class="el" href="../../d3/dcb/classorg_1_1apache_1_1lucene_1_1store_1_1_directory.html#a6483e5b21d769a15e83cdadc3174a463" title="Ensures that any writes to these files are moved to stable storage (made durable). ">Directory.sync</a> on the index files. That call should not return until the file contents and metadata are on stable storage. For FSDirectory, this calls the OS's fsync. But, beware: some hardware devices may in fact cache writes even during fsync, and return before the bits are actually on stable storage, to give the appearance of faster performance. If you have such a device, and it does not have a battery backup (for example) then on power loss it may still lose data. Lucene cannot guarantee consistency on such devices. </p>
<p>If nothing was committed, because there were no pending changes, this returns -1. Otherwise, it returns the sequence number such that all indexing operations prior to this sequence will be included in the commit point, and all other operations will not. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a43fe1cca1e61c4e749d72e7c9918540a">prepareCommit</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> of the last operation in the commit. All sequence numbers &lt;= this value will be reflected in the commit, and all others will not. </dd></dl>

<p>Implements <a class="el" href="../../de/d0f/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_two_phase_commit.html#a12175b2175cfe9709f4d9418a2568e2e">org.apache.lucene.index.TwoPhaseCommit</a>.</p>

</div>
</div>
<a id="a5b4c1d7e8169e14c846fe6b46b1f579d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4c1d7e8169e14c846fe6b46b1f579d">&#9670;&nbsp;</a></span>decRefDeleter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.apache.lucene.index.IndexWriter.decRefDeleter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a>&#160;</td>
          <td class="paramname"><em>segmentInfos</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that the files referenced by this <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a> are no longer in use. </p>
<p>Only call this if you are sure you previously called <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a9a9cd3ff1819e51d456a40537bca5a5f">incRefDeleter</a>.</p>
<p>.internal </p>

</div>
</div>
<a id="ade4721e74766499fa7a1da53881e7b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4721e74766499fa7a1da53881e7b60">&#9670;&nbsp;</a></span>deleteAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.deleteAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all documents in the index. </p>
<p>This method will drop all buffered documents and will remove all segments from the index. This change will not be visible until a <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> has been called. This method can be rolled back using <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aa7ba70af74683a8c7d8f2b4527f8b41b">rollback()</a>. </p>
<p>NOTE: this method is much faster than using deleteDocuments( new MatchAllDocsQuery() ). Yet, this method also has different semantics compared to <a class="el" href="../../">deleteDocuments(Query...)</a> since internal data-structures are cleared as well as all segment information is forcefully dropped anti-viral semantics like omitting norms are reset or doc value types are cleared. Essentially a call to <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ade4721e74766499fa7a1da53881e7b60">deleteAll()</a> is equivalent to creating a new <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html">IndexWriter</a> with <a class="el" href="../../">OpenMode#CREATE</a> which a delete query only marks documents as deleted. </p>
<p>NOTE: this method will forcefully abort all merges in progress. If other threads are running <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad43c2e7d16d5d9e3a41e50a05316f0e5">forceMerge</a>, <a class="el" href="../../">addIndexes(CodecReader[])</a> or <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#acdb9a8fe2787af1d6f1ac17f3e3eee3e">forceMergeDeletes</a> methods, they may receive <a class="el" href="../../">MergePolicy.MergeAbortedException</a>s.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation </dd></dl>

</div>
</div>
<a id="a748113d653d04e11d80107311f66ee0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748113d653d04e11d80107311f66ee0e">&#9670;&nbsp;</a></span>deleteDocuments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.deleteDocuments </td>
          <td>(</td>
          <td class="paramtype">Term...&#160;</td>
          <td class="paramname"><em>terms</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the document(s) containing any of the terms. </p>
<p>All given deletes are applied and flushed atomically at the same time.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terms</td><td>array of terms to identify the documents to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a1a4dfa5d5d183ae479031a2d73afaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1a4dfa5d5d183ae479031a2d73afaf">&#9670;&nbsp;</a></span>deleteDocuments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.deleteDocuments </td>
          <td>(</td>
          <td class="paramtype">Query...&#160;</td>
          <td class="paramname"><em>queries</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the document(s) matching any of the provided queries. </p>
<p>All given deletes are applied and flushed atomically at the same time.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queries</td><td>array of queries to identify the documents to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fbceb644a4a164f0308e3b074a57a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbceb644a4a164f0308e3b074a57a60">&#9670;&nbsp;</a></span>deleteUnusedFiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.apache.lucene.index.IndexWriter.deleteUnusedFiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: remove any index files that are no longer used. </p>
<p><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> normally deletes unused files itself, during indexing. However, on Windows, which disallows deletion of open files, if there is a reader open on the index then those files cannot be deleted. This is fine, because <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> will periodically retry the deletion.</p>
<p>However, <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> doesn't try that often: only on open, close, flushing a new segment, and finishing a merge. If you don't do any of these actions with your <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a>, you'll see the unused files linger. If that's a problem, call this method to delete them (once you've closed the open readers that were preventing their deletion).</p>
<p>In addition, you can call this method to delete unreferenced index commits. This might be useful if you are using an <a class="el" href="../../d8/dcd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_deletion_policy.html">IndexDeletionPolicy</a> which holds onto index commits until some criteria are met, but those commits are no longer needed. Otherwise, those commits will be deleted the next time <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> is called. </p>

</div>
</div>
<a id="ae78ca58f57b4beaa80306cbfbb0654ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78ca58f57b4beaa80306cbfbb0654ee">&#9670;&nbsp;</a></span>ensureOpen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final void org.apache.lucene.index.IndexWriter.ensureOpen </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>failIfClosing</em></td><td>)</td>
          <td> throws <a class="el" href="../../db/d65/classorg_1_1apache_1_1lucene_1_1store_1_1_already_closed_exception.html">AlreadyClosedException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to throw an <a class="el" href="../../">AlreadyClosedException</a> if this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> has been closed or is in the process of closing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">failIfClosing</td><td>if true, also fail when<div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --> is in the process of closing (<div class="fragment"><div class="line">closing=<span class="keyword">true</span> </div></div><!-- fragment --> ) but not yet done closing ( <div class="fragment"><div class="line">closed=<span class="keyword">false</span> </div></div><!-- fragment --> ) </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">AlreadyClosedException</td><td>if this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> is closed or in the process of closing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72c5781d3e3dbcccd5182e90db20f175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c5781d3e3dbcccd5182e90db20f175">&#9670;&nbsp;</a></span>ensureOpen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final void org.apache.lucene.index.IndexWriter.ensureOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws <a class="el" href="../../db/d65/classorg_1_1apache_1_1lucene_1_1store_1_1_already_closed_exception.html">AlreadyClosedException</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used internally to throw an <a class="el" href="../../">AlreadyClosedException</a> if this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> has been closed (. </p>
<div class="fragment"><div class="line">closed=<span class="keyword">true</span> </div></div><!-- fragment --><p> ) or is in the process of closing (</p><div class="fragment"><div class="line">closing=<span class="keyword">true</span> </div></div><!-- fragment --><p> ). </p>
<p>Calls <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ae78ca58f57b4beaa80306cbfbb0654ee">ensureOpen(true)</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">AlreadyClosedException</td><td>if this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> is closed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36d48a48833afff4cb4819b12e498e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d48a48833afff4cb4819b12e498e6e">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final void org.apache.lucene.index.IndexWriter.flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves all in-memory segments to the <a class="el" href="../../">Directory</a>, but does not commit (fsync) them (call <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit</a> for that). </p>

</div>
</div>
<a id="a38ec85d7a69ecf96994f8d2186561a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ec85d7a69ecf96994f8d2186561a0d">&#9670;&nbsp;</a></span>flushNextBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final boolean org.apache.lucene.index.IndexWriter.flushNextBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expert: Flushes the next pending writer per thread buffer if available or the largest active non-pending writer per thread buffer in the calling thread. This can be used to flush documents to disk outside of an indexing thread. In contrast to <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a36d48a48833afff4cb4819b12e498e6e">flush()</a> this won't mark all currently active indexing buffers as flush-pending.</p>
<p>Note: this method is best-effort and might not flush any segments to disk. If there is a full flush happening concurrently multiple segments might have been flushed. Users of this API can access the IndexWriters current memory consumption via <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a19030933712b5c82396bb0a45cf54c53">ramBytesUsed()</a> </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> iff this method flushed at least on segment to disk. .experimental </dd></dl>

</div>
</div>
<a id="ad43c2e7d16d5d9e3a41e50a05316f0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43c2e7d16d5d9e3a41e50a05316f0e5">&#9670;&nbsp;</a></span>forceMerge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.forceMerge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumSegments</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces merge policy to merge segments until there are. </p>
<div class="fragment"><div class="line">&lt;= maxNumSegments </div></div><!-- fragment --><p> . The actual merges to be executed are determined by the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a>.</p>
<p>This is a horribly costly operation, especially when you pass a small</p><div class="fragment"><div class="line">maxNumSegments </div></div><!-- fragment --><p> ; usually you should only call this if the index is static (will no longer be changed).</p>
<p>Note that this requires free space that is proportional to the size of the index in your Directory: 2X if you are not using compound file format, and 3X if you are. For example, if your index size is 10 MB then you need an additional 20 MB free for this to complete (30 MB if you're using compound file format). This is also affected by the <a class="el" href="../../">Codec</a> that is used to execute the merge, and may result in even a bigger index. Also, it's best to call <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> afterwards, to allow <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> to free up disk space.</p>
<p>If some but not all readers re-open while merging is underway, this will cause</p><div class="fragment"><div class="line">&gt; 2X </div></div><!-- fragment --><p> temporary space to be consumed as those new readers will then hold open the temporary segments at that time. It is best not to re-open readers while merging is running.</p>
<p>The actual temporary usage could be much less than these figures (it depends on many factors).</p>
<p>In general, once this completes, the total size of the index will be less than the size of the starting index. It could be quite a bit smaller (if there were many pending deletes) or just slightly smaller.</p>
<p>If an Exception is hit, for example due to disk full, the index will not be corrupted and no documents will be lost. However, it may have been partially merged (some segments were merged but not all), and it's possible that one of the segments in the index will be in non-compound format even when using compound file format. This will occur when the Exception is hit during conversion of the segment into compound format.</p>
<p>This call will merge those segments present in the index when the call started. If other threads are still adding documents and flushing segments, those newly created segments will not be merged unless you call forceMerge again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNumSegments</td><td>maximum number of segments left in the index after merging finishes</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html#a43de271663913ac98826e6a624a29769" title="Determine what set of merge operations are now necessary on the index. ">MergePolicy::findMerges</a> </dd></dl>

</div>
</div>
<a id="a51292f6cdb25fe7b1b8aa73337edd36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51292f6cdb25fe7b1b8aa73337edd36c">&#9670;&nbsp;</a></span>forceMerge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.forceMerge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>doWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just like <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ad43c2e7d16d5d9e3a41e50a05316f0e5">forceMerge(int)</a>, except you can specify whether the call should block until all merging completes. </p>
<p>This is only meaningful with a <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a> that is able to run merges in background threads. </p>

</div>
</div>
<a id="acdb9a8fe2787af1d6f1ac17f3e3eee3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb9a8fe2787af1d6f1ac17f3e3eee3e">&#9670;&nbsp;</a></span>forceMergeDeletes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.forceMergeDeletes </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>doWait</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just like <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a70570e9d106a1e44774401c32e02f005">forceMergeDeletes()</a>, except you can specify whether the call should block until the operation completes. </p>
<p>This is only meaningful with a <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a> that is able to run merges in background threads. </p>

</div>
</div>
<a id="a70570e9d106a1e44774401c32e02f005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70570e9d106a1e44774401c32e02f005">&#9670;&nbsp;</a></span>forceMergeDeletes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.forceMergeDeletes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces merging of all segments that have deleted documents. </p>
<p>The actual merges to be executed are determined by the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a>. For example, the default <a class="el" href="../../d0/d5d/classorg_1_1apache_1_1lucene_1_1index_1_1_tiered_merge_policy.html">TieredMergePolicy</a> will only pick a segment if the percentage of deleted docs is over 10%.</p>
<p>This is often a horribly costly operation; rarely is it warranted.</p>
<p>To see how many deletions you have pending in your index, call <a class="el" href="../../df/de9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_reader.html#ab0d563ea584604ce3ea36c5a0b06a94e">IndexReader#numDeletedDocs</a>.</p>
<p><b>NOTE</b>: this method first flushes a new segment (if there are indexed documents), and applies all buffered deletes. </p>

</div>
</div>
<a id="a6d701a233fa5f828d58d2956389f769d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d701a233fa5f828d58d2956389f769d">&#9670;&nbsp;</a></span>getAnalyzer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">Analyzer</a> org.apache.lucene.index.IndexWriter.getAnalyzer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the analyzer used by this index. </p>

</div>
</div>
<a id="af307e3b9754144535ee4e8772a6bf2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af307e3b9754144535ee4e8772a6bf2fd">&#9670;&nbsp;</a></span>getDirectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/dcb/classorg_1_1apache_1_1lucene_1_1store_1_1_directory.html">Directory</a> org.apache.lucene.index.IndexWriter.getDirectory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the Directory used by this index. </p>

</div>
</div>
<a id="a313d85133bc2a600dd2dc6a70d5b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313d85133bc2a600dd2dc6a70d5b0f38">&#9670;&nbsp;</a></span>getFieldNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Set&lt;String&gt; org.apache.lucene.index.IndexWriter.getFieldNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return an unmodifiable set of all field names as visible from this <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a>, across all segments of the index. </p>
<p>Useful for knowing which fields exist, before <a class="el" href="../../">updateDocValues(Term, Field...)</a> is attempted. We could phase out this method if <a class="el" href="../../">updateDocValues(Term, Field...)</a> could create the non-existent docValues fields as necessary, instead of throwing IllegalArgumentException for attempts to update non-existent docValues fields. .internal .experimental </p>

</div>
</div>
<a id="a808812c144444de2c277ea4b8147194c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808812c144444de2c277ea4b8147194c">&#9670;&nbsp;</a></span>getMaxCompletedSequenceNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.getMaxCompletedSequenceNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the highest <a href="../../#sequence_number">sequence number</a> across all completed operations, or 0 if no operations have finished yet. </p>
<p>Still in-flight operations (in other threads) are not counted until they finish.</p>
<p>.experimental </p>

</div>
</div>
<a id="acdab41dabb53342b69614ad3796ae4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdab41dabb53342b69614ad3796ae4b6">&#9670;&nbsp;</a></span>getMergingSegments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized Set&lt;<a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html">SegmentCommitInfo</a>&gt; org.apache.lucene.index.IndexWriter.getMergingSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: to be used by a <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a> to avoid selecting merges for segments already being merged. </p>
<p>The returned collection is not cloned, and thus is only safe to access if you hold <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a>'s lock (which you do when <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a> invokes the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a>).</p>
<p>The Set is unmodifiable. </p>

<p>Implements <a class="el" href="../../d2/d9b/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy_1_1_merge_context.html#af1b09118bff3220141b925dba16f889c">org.apache.lucene.index.MergePolicy.MergeContext</a>.</p>

</div>
</div>
<a id="a6448ddeddb776d02fbfa77aeb763f78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6448ddeddb776d02fbfa77aeb763f78e">&#9670;&nbsp;</a></span>getNextMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized MergePolicy.OneMerge org.apache.lucene.index.IndexWriter.getNextMerge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: the <a class="el" href="../../d1/d4e/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_scheduler.html">MergeScheduler</a> calls this method to retrieve the next merge requested by the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a>. </p>
<p>.experimental </p>

</div>
</div>
<a id="a5523c93b54c2bc4eb6eb061c28ac9404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5523c93b54c2bc4eb6eb061c28ac9404">&#9670;&nbsp;</a></span>getTragicException()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Throwable org.apache.lucene.index.IndexWriter.getTragicException </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If this. </p>
<div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --><p> was closed as a side-effect of a tragic exception, e.g. disk full while flushing a new segment, this returns the root cause exception. Otherwise (no tragic exception has occurred) it returns null. </p>

</div>
</div>
<a id="a99b6faf5a23c51a4cb44f1cca304ae9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b6faf5a23c51a4cb44f1cca304ae9f">&#9670;&nbsp;</a></span>hasDeletions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized boolean org.apache.lucene.index.IndexWriter.hasDeletions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this index has deletions (including buffered deletions). </p>
<p>Note that this will return true if there are buffered Term/Query deletions, even if it turns out those buffered deletions don't match any documents. </p>

</div>
</div>
<a id="ae76873f159270ebcbb7157a935ea71bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76873f159270ebcbb7157a935ea71bd">&#9670;&nbsp;</a></span>hasPendingMerges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized boolean org.apache.lucene.index.IndexWriter.hasPendingMerges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: returns true if there are merges waiting to be scheduled. </p>
<p>.experimental </p>

</div>
</div>
<a id="ab873511dc8d59658722b1303f6f513aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab873511dc8d59658722b1303f6f513aa">&#9670;&nbsp;</a></span>hasUncommittedChanges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final boolean org.apache.lucene.index.IndexWriter.hasUncommittedChanges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there may be changes that have not been committed. </p>
<p>There are cases where this may return true when there are no actual "real" changes to the index, for example if you've deleted by <a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html" title="A Term represents a word from text. ">Term</a> or Query but that <a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html" title="A Term represents a word from text. ">Term</a> or Query does not match any documents. Also, if a merge kicked off as a result of flushing a new segment during <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit</a>, or a concurrent merged finished, this method may return true right after you had just called <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit</a>. </p>

</div>
</div>
<a id="a9a9cd3ff1819e51d456a40537bca5a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9cd3ff1819e51d456a40537bca5a5f">&#9670;&nbsp;</a></span>incRefDeleter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.apache.lucene.index.IndexWriter.incRefDeleter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a>&#160;</td>
          <td class="paramname"><em>segmentInfos</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record that the files referenced by this <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html">SegmentInfos</a> are still in use. </p>
<p>.internal </p>

</div>
</div>
<a id="a01fab00c579190f6a5144f99c3ec8bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fab00c579190f6a5144f99c3ec8bed">&#9670;&nbsp;</a></span>isEnableTestPoints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.apache.lucene.index.IndexWriter.isEnableTestPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests should override this to enable test points. </p>
<p>Default is <code>false</code>. </p>

</div>
</div>
<a id="a8ca35630ce6ee092afe56ab4be3d9079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca35630ce6ee092afe56ab4be3d9079">&#9670;&nbsp;</a></span>isOpen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.apache.lucene.index.IndexWriter.isOpen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns. </p>
<div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --><p> if this</p><div class="fragment"><div class="line"><a class="code" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a38c26566b00ba10ba6c5b89ce0f35734">IndexWriter</a> </div></div><!-- fragment --><p> is still open. </p>

</div>
</div>
<a id="aba0b7015f1ccc54ce566b352078e0b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0b7015f1ccc54ce566b352078e0b66">&#9670;&nbsp;</a></span>maxDoc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized int org.apache.lucene.index.IndexWriter.maxDoc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), not counting deletions. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ab0ab37d46bb3c32c302acdedd007c5ef" title="Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer)...">numDocs</a> </dd></dl>

</div>
</div>
<a id="a259c8826984a7feb988a51328f00cb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259c8826984a7feb988a51328f00cb60">&#9670;&nbsp;</a></span>maybeMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final void org.apache.lucene.index.IndexWriter.maybeMerge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merges and then iterate (test again if merges are needed) until no more merges are returned by the mergePolicy. </p>
<p>Explicit calls to <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a259c8826984a7feb988a51328f00cb60" title="Expert: asks the mergePolicy whether any merges are necessary now and if so, runs the requested merge...">maybeMerge()</a> are usually not necessary. The most common case is when merge policy parameters have changed.</p>
<p>This method will call the <a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html">MergePolicy</a> with <a class="el" href="../../dd/dd6/enumorg_1_1apache_1_1lucene_1_1index_1_1_merge_trigger.html#a2e03a8138e8c257e59f558ec0080bb97">MergeTrigger#EXPLICIT</a>. </p>

</div>
</div>
<a id="a96e4c4638add0e7631a3966d79ec81ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e4c4638add0e7631a3966d79ec81ee">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.merge </td>
          <td>(</td>
          <td class="paramtype">MergePolicy.OneMerge&#160;</td>
          <td class="paramname"><em>merge</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the indicated segments, replacing them in the stack with a single segment. </p>
<p>.experimental </p>

</div>
</div>
<a id="a2faa3105dec3d21f2d4bb8e50f1e2fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2faa3105dec3d21f2d4bb8e50f1e2fce">&#9670;&nbsp;</a></span>numDeletedDocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.apache.lucene.index.IndexWriter.numDeletedDocs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html">SegmentCommitInfo</a>&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the number of deleted docs for a pooled reader. </p>
<p>If the reader isn't being pooled, the segmentInfo's delCount is returned. </p>

<p>Implements <a class="el" href="../../d2/d9b/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy_1_1_merge_context.html#a6980e065b77ea3b0f86735e0f50015a4">org.apache.lucene.index.MergePolicy.MergeContext</a>.</p>

</div>
</div>
<a id="acb4507676a73a0274b3f36cbacdcf63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4507676a73a0274b3f36cbacdcf63e">&#9670;&nbsp;</a></span>numDeletesToMerge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final int org.apache.lucene.index.IndexWriter.numDeletesToMerge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html">SegmentCommitInfo</a>&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of deletes a merge would claim back if the given segment is merged. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d3/d42/classorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy.html#afa2933bf91f60a20fc4cf406bbef7223" title="Returns the number of deletes that a merge would claim on the given segment. ">MergePolicy::numDeletesToMerge</a>(<a class="el" href="../../d3/df8/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_commit_info.html" title="Embeds a [read-only] SegmentInfo and adds per-commit fields. ">SegmentCommitInfo</a>, int, <a class="el" href="../../d7/d76/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_i_o_supplier.html" title="This is a result supplier that is allowed to throw an IOException. ">org.apache.lucene.util.IOSupplier</a>) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>the segment to get the number of deletes for .experimental </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../d2/d9b/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_merge_policy_1_1_merge_context.html#a49e3251de05708b2d606448a519076b2">org.apache.lucene.index.MergePolicy.MergeContext</a>.</p>

</div>
</div>
<a id="ab0ab37d46bb3c32c302acdedd007c5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ab37d46bb3c32c302acdedd007c5ef">&#9670;&nbsp;</a></span>numDocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized int org.apache.lucene.index.IndexWriter.numDocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer), and including deletions. </p>
<p><b>NOTE:</b> buffered deletions are not counted. If you really need these to be counted you should call <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> first. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#ab0ab37d46bb3c32c302acdedd007c5ef" title="Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer)...">numDocs</a> </dd></dl>

</div>
</div>
<a id="a7718325dc0f31bae2936b222c3f8c71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7718325dc0f31bae2936b222c3f8c71c">&#9670;&nbsp;</a></span>numRamDocs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final synchronized int org.apache.lucene.index.IndexWriter.numRamDocs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: Return the number of documents currently buffered in RAM. </p>

</div>
</div>
<a id="a43fe1cca1e61c4e749d72e7c9918540a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fe1cca1e61c4e749d72e7c9918540a">&#9670;&nbsp;</a></span>prepareCommit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final long org.apache.lucene.index.IndexWriter.prepareCommit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expert: prepare for commit. This does the first phase of 2-phase commit. This method does all steps necessary to commit changes since this writer was opened: flushes pending added and deleted docs, syncs the index files, writes most of next segments_N file. After calling this you must call either <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> to finish the commit, or <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#aa7ba70af74683a8c7d8f2b4527f8b41b">rollback()</a> to revert the commit and undo all changes done since the writer was opened.</p>
<p>You can also just call <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> directly without prepareCommit first in which case that method will internally call prepareCommit.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> of the last operation in the commit. All sequence numbers &lt;= this value will be reflected in the commit, and all others will not. </dd></dl>

<p>Implements <a class="el" href="../../de/d0f/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_two_phase_commit.html#ae8b03651322fcb667bdf60e6acb7e6a4">org.apache.lucene.index.TwoPhaseCommit</a>.</p>

</div>
</div>
<a id="a19030933712b5c82396bb0a45cf54c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19030933712b5c82396bb0a45cf54c53">&#9670;&nbsp;</a></span>ramBytesUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final long org.apache.lucene.index.IndexWriter.ramBytesUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the memory usage of this object in bytes. </p>
<p>Negative values are illegal. </p>

<p>Implements <a class="el" href="../../db/de6/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_accountable.html#a084b7108fbb5b4f81b671170544da484">org.apache.lucene.util.Accountable</a>.</p>

</div>
</div>
<a id="aa7ba70af74683a8c7d8f2b4527f8b41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ba70af74683a8c7d8f2b4527f8b41b">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.apache.lucene.index.IndexWriter.rollback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the <code><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html" title="An IndexWriter creates and maintains an index. ">IndexWriter</a></code> without committing any changes that have occurred since the last commit (or since it was opened, if commit hasn't been called). </p>
<p>This removes any temporary files that had been created, after which the state of the index will be the same as it was when <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a> was last called or when this writer was first opened. This also clears a previous call to <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a43fe1cca1e61c4e749d72e7c9918540a">prepareCommit</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../de/d0f/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_two_phase_commit.html#a12b9eb861299e6ff8b95098db9bfb64f">org.apache.lucene.index.TwoPhaseCommit</a>.</p>

</div>
</div>
<a id="a57ce5f1d9dbf1a524d725b3643c73a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ce5f1d9dbf1a524d725b3643c73a32">&#9670;&nbsp;</a></span>setLiveCommitData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final synchronized void org.apache.lucene.index.IndexWriter.setLiveCommitData </td>
          <td>(</td>
          <td class="paramtype">Iterable&lt; Map.Entry&lt; String, String &gt;&gt;&#160;</td>
          <td class="paramname"><em>commitUserData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the iterator to provide the commit user data map at commit time. </p>
<p>Calling this method is considered a committable change and will be <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">committed</a> even if there are no other changes this writer. Note that you must call this method before <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a43fe1cca1e61c4e749d72e7c9918540a">prepareCommit()</a>. Otherwise it won't be included in the follow-on <a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html#a09b235328bc02558089135f219ac9a01">commit()</a>. </p>
<p><b>NOTE:</b> the iterator is late-binding: it is only visited once all documents for the commit have been written to their segments, before the next segments_N file is written </p>

</div>
</div>
<a id="a532a7ede6e3225d97c28fe5e0afc09e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532a7ede6e3225d97c28fe5e0afc09e9">&#9670;&nbsp;</a></span>setLiveCommitData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final synchronized void org.apache.lucene.index.IndexWriter.setLiveCommitData </td>
          <td>(</td>
          <td class="paramtype">Iterable&lt; Map.Entry&lt; String, String &gt;&gt;&#160;</td>
          <td class="paramname"><em>commitUserData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>doIncrementVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the commit user data iterator, controlling whether to advance the <a class="el" href="../../d7/dd4/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_infos.html#a7f48e0163cbaf934b6799fb0482a2af0">SegmentInfos#getVersion</a>. </p>
<dl class="section see"><dt>See also</dt><dd>#setLiveCommitData(Iterable)</dd></dl>
<p>.internal </p>

</div>
</div>
<a id="ae4657245f3b0f7d35eb02d0260be3523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4657245f3b0f7d35eb02d0260be3523">&#9670;&nbsp;</a></span>softUpdateDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.softUpdateDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&#160;</td>
          <td class="paramname"><em>doc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field...&#160;</td>
          <td class="paramname"><em>softDeletes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: Updates a document by first updating the document(s) containing <code>term</code> with the given doc-values fields and then adding the new document. </p>
<p>The doc-values update and then add are atomic as seen by a reader on the same index (flush may happen only after the add).</p>
<p>One use of this API is to retain older versions of documents instead of replacing them. The existing documents can be updated to reflect they are no longer current while atomically adding new documents at the same time.</p>
<p>In contrast to <a class="el" href="../../">updateDocument(Term, Iterable)</a> this method will not delete documents in the index matching the given term but instead update them with the given doc-values fields which can be used as a soft-delete mechanism.</p>
<p>See <a class="el" href="../../">addDocuments(Iterable)</a> and <a class="el" href="../../">updateDocuments(Term, Iterable)</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error</td></tr>
  </table>
  </dd>
</dl>
<p>.experimental </p>

</div>
</div>
<a id="a12972fbd618898ed9e7f8507044de503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12972fbd618898ed9e7f8507044de503">&#9670;&nbsp;</a></span>softUpdateDocuments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.softUpdateDocuments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable&lt;? extends Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>docs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field...&#160;</td>
          <td class="paramname"><em>softDeletes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: Atomically updates documents matching the provided term with the given doc-values fields and adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents. </p>
<p>One use of this API is to retain older versions of documents instead of replacing them. The existing documents can be updated to reflect they are no longer current while atomically adding new documents at the same time.</p>
<p>In contrast to <a class="el" href="../../">updateDocuments(Term, Iterable)</a> this method will not delete documents in the index matching the given term but instead update them with the given doc-values fields which can be used as a soft-delete mechanism.</p>
<p>See <a class="el" href="../../">addDocuments(Iterable)</a> and <a class="el" href="../../">updateDocuments(Term, Iterable)</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error</td></tr>
  </table>
  </dd>
</dl>
<p>.experimental </p>

</div>
</div>
<a id="a707e27bdf0c81b2daecd7951e49992c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e27bdf0c81b2daecd7951e49992c4">&#9670;&nbsp;</a></span>tryDeleteDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized long org.apache.lucene.index.IndexWriter.tryDeleteDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/de9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_reader.html">IndexReader</a>&#160;</td>
          <td class="paramname"><em>readerIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>docID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: attempts to delete by document ID, as long as the provided reader is a near-real-time reader (from <a class="el" href="../../df/dfb/classorg_1_1apache_1_1lucene_1_1index_1_1_directory_reader.html#ac7a107c2a70fda71bb38bfdf4606e731">DirectoryReader#open(IndexWriter)</a>). </p>
<p>If the provided reader is an NRT reader obtained from this writer, and its segment has not been merged away, then the delete succeeds and this method returns a valid (&gt; 0) sequence number; else, it returns -1 and the caller must then separately delete by <a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html" title="A Term represents a word from text. ">Term</a> or Query.</p>
<p><b>NOTE</b>: this method can only delete documents visible to the currently open NRT reader. If you need to delete documents indexed after opening the NRT reader you must use <a class="el" href="../../">deleteDocuments(Term...)</a>). </p>

</div>
</div>
<a id="ac116c0e5ad5513e442c03e487c7c07c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac116c0e5ad5513e442c03e487c7c07c9">&#9670;&nbsp;</a></span>tryUpdateDocValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized long org.apache.lucene.index.IndexWriter.tryUpdateDocValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/de9/classorg_1_1apache_1_1lucene_1_1index_1_1_index_reader.html">IndexReader</a>&#160;</td>
          <td class="paramname"><em>readerIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>docID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field...&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expert: attempts to update doc values by document ID, as long as the provided reader is a near-real-time reader (from <a class="el" href="../../df/dfb/classorg_1_1apache_1_1lucene_1_1index_1_1_directory_reader.html#ac7a107c2a70fda71bb38bfdf4606e731">DirectoryReader#open(IndexWriter)</a>). </p>
<p>If the provided reader is an NRT reader obtained from this writer, and its segment has not been merged away, then the update succeeds and this method returns a valid (&gt; 0) sequence number; else, it returns -1 and the caller must then either retry the update and resolve the document again. If a doc values fields data is <code>null</code> the existing value is removed from all documents matching the term. This can be used to un-delete a soft-deleted document since this method will apply the field update even if the document is marked as deleted.</p>
<p><b>NOTE</b>: this method can only updates documents visible to the currently open NRT reader. If you need to update documents indexed after opening the NRT reader you must use <a class="el" href="../../">updateDocValues(Term, Field...)</a>. </p>

</div>
</div>
<a id="aa4baf547cd2be0ddbbd41b6a8685396e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4baf547cd2be0ddbbd41b6a8685396e">&#9670;&nbsp;</a></span>updateBinaryDocValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.updateBinaryDocValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/db3/classorg_1_1apache_1_1lucene_1_1util_1_1_bytes_ref.html">BytesRef</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a document's <a class="el" href="../../dc/d40/classorg_1_1apache_1_1lucene_1_1index_1_1_binary_doc_values.html">BinaryDocValues</a> for <code>field</code> to the given <code>value</code>. </p>
<p>You can only update fields that already exist in the index, not add new fields through this method.</p>
<p><b>NOTE:</b> this method currently replaces the existing value of all affected documents with the new value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to identify the document(s) to be updated </td></tr>
    <tr><td class="paramname">field</td><td>field name of the <a class="el" href="../../dc/d40/classorg_1_1apache_1_1lucene_1_1index_1_1_binary_doc_values.html">BinaryDocValues</a> field </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36bb3b6f10588be347ecacaefc960d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bb3b6f10588be347ecacaefc960d17">&#9670;&nbsp;</a></span>updateDocument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.updateDocument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&#160;</td>
          <td class="paramname"><em>doc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a document by first deleting the document(s) containing <code>term</code> and then adding the new document. </p>
<p>The delete and then add are atomic as seen by a reader on the same index (flush may happen only after the add).</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to identify the document(s) to be deleted </td></tr>
    <tr><td class="paramname">doc</td><td>the document to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa503e296be695e7cbd8efd16cca7edac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa503e296be695e7cbd8efd16cca7edac">&#9670;&nbsp;</a></span>updateDocuments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.updateDocuments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>delTerm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterable&lt;? extends Iterable&lt;? extends <a class="el" href="../../dc/dce/interfaceorg_1_1apache_1_1lucene_1_1index_1_1_indexable_field.html">IndexableField</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>docs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Atomically deletes documents matching the provided delTerm and adds a block of documents with sequentially assigned document IDs, such that an external reader will see all or none of the documents. </p>
<p>See <a class="el" href="../../">addDocuments(Iterable)</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error</td></tr>
  </table>
  </dd>
</dl>
<p>.experimental </p>

</div>
</div>
<a id="aea54ee60f5df1cdaca1769e45728f3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea54ee60f5df1cdaca1769e45728f3a5">&#9670;&nbsp;</a></span>updateDocValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.updateDocValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Field...&#160;</td>
          <td class="paramname"><em>updates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates documents' <a class="el" href="../../d3/d1b/classorg_1_1apache_1_1lucene_1_1index_1_1_doc_values.html" title="This class contains utility methods and constants for DocValues. ">DocValues</a> fields to the given values. </p>
<p>Each field update is applied to the set of documents that are associated with the <a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a> to the same value. All updates are atomically applied and flushed together. If a doc values fields data is <code>null</code> the existing value is removed from all documents matching the term.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">updates</td><td>the updates to apply</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfd7d781c4b8a3c561f0d1581d136c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd7d781c4b8a3c561f0d1581d136c30">&#9670;&nbsp;</a></span>updateNumericDocValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.apache.lucene.index.IndexWriter.updateNumericDocValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d58/classorg_1_1apache_1_1lucene_1_1index_1_1_term.html">Term</a>&#160;</td>
          <td class="paramname"><em>term</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> throws IOException</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a document's <a class="el" href="../../dd/d91/classorg_1_1apache_1_1lucene_1_1index_1_1_numeric_doc_values.html">NumericDocValues</a> for <code>field</code> to the given <code>value</code>. </p>
<p>You can only update fields that already exist in the index, not add new fields through this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">term</td><td>the term to identify the document(s) to be updated </td></tr>
    <tr><td class="paramname">field</td><td>field name of the <a class="el" href="../../dd/d91/classorg_1_1apache_1_1lucene_1_1index_1_1_numeric_doc_values.html">NumericDocValues</a> field </td></tr>
    <tr><td class="paramname">value</td><td>new value for the field</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a href="../../#sequence_number">sequence number</a> for this operation</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="../../d6/d9c/classorg_1_1apache_1_1lucene_1_1index_1_1_corrupt_index_exception.html" title="This exception is thrown when Lucene detects an inconsistency in the index. ">CorruptIndexException</a></td><td>if the index is corrupt </td></tr>
    <tr><td class="paramname">IOException</td><td>if there is a low-level IO error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af267b45e57b9fd6d15964b1e22fdd35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af267b45e57b9fd6d15964b1e22fdd35d">&#9670;&nbsp;</a></span>MAX_DOCS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final int org.apache.lucene.index.IndexWriter.MAX_DOCS = Integer.MAX_VALUE - 128</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hard limit on maximum number of documents that may be added to the index. </p>
<p>If you try to add more than this you'll hit</p><div class="fragment"><div class="line">IllegalArgumentException </div></div><!-- fragment --><p> . </p>

</div>
</div>
<a id="a86a5e2920fe8656d139dd9de1e874bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a5e2920fe8656d139dd9de1e874bad">&#9670;&nbsp;</a></span>MAX_POSITION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final int org.apache.lucene.index.IndexWriter.MAX_POSITION = Integer.MAX_VALUE - 128</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum value of the token position in an indexed field. </p>

</div>
</div>
<a id="afd06d12ac1b83b91808a2715bc3ac121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06d12ac1b83b91808a2715bc3ac121">&#9670;&nbsp;</a></span>MAX_TERM_LENGTH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final int org.apache.lucene.index.IndexWriter.MAX_TERM_LENGTH = DocumentsWriterPerThread.MAX_TERM_LENGTH_UTF8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute hard maximum length for a term, in bytes once encoded as UTF8. </p>
<p>If a term arrives from the analyzer longer than this length, an <code>IllegalArgumentException</code> is thrown and a message is printed to infoStream, if set (see <a class="el" href="../../d2/dbd/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer_config.html#a9d9dd5fd46cbf6e61493c56ca025a7d8">IndexWriterConfig#setInfoStream(InfoStream)</a>). </p>

</div>
</div>
<a id="a4cc345a1fdc69cde2c9959422098ba52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc345a1fdc69cde2c9959422098ba52">&#9670;&nbsp;</a></span>SOURCE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final String org.apache.lucene.index.IndexWriter.SOURCE = &quot;source&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key for the source of a segment in the <a class="el" href="../../d2/d9b/classorg_1_1apache_1_1lucene_1_1index_1_1_segment_info.html#a446c10af6e5180377b6518137887d507">diagnostics</a>. </p>

</div>
</div>
<a id="af3f0feed7029ba6a2ffd5e533923f317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f0feed7029ba6a2ffd5e533923f317">&#9670;&nbsp;</a></span>SOURCE_ADDINDEXES_READERS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final String org.apache.lucene.index.IndexWriter.SOURCE_ADDINDEXES_READERS = &quot;addIndexes(CodecReader...)&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source of a segment which results from a call to <a class="el" href="../../">addIndexes(CodecReader...)</a>. </p>

</div>
</div>
<a id="a54d27aea5fb559a8009584cb155ceaea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d27aea5fb559a8009584cb155ceaea">&#9670;&nbsp;</a></span>SOURCE_FLUSH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final String org.apache.lucene.index.IndexWriter.SOURCE_FLUSH = &quot;flush&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source of a segment which results from a flush. </p>

</div>
</div>
<a id="a3a4e46c2b99551a3ed9439d25d3dafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4e46c2b99551a3ed9439d25d3dafdc">&#9670;&nbsp;</a></span>SOURCE_MERGE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">final String org.apache.lucene.index.IndexWriter.SOURCE_MERGE = &quot;merge&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source of a segment which results from a merge of other segments. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/vkroz/src/oss/lucene-solr/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>org</b></li><li class="navelem"><b>apache</b></li><li class="navelem"><a class="el" href="../../d8/d76/namespaceorg_1_1apache_1_1lucene.html">lucene</a></li><li class="navelem"><a class="el" href="../../d2/d12/namespaceorg_1_1apache_1_1lucene_1_1index.html">index</a></li><li class="navelem"><a class="el" href="../../df/dbc/classorg_1_1apache_1_1lucene_1_1index_1_1_index_writer.html">IndexWriter</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
