<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lucene-core-API: Package org.apache.lucene.analysis</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lucene-core-API
   &#160;<span id="projectnumber">8.0.0-SNAPSHOT</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d7/d36/namespaceorg_1_1apache_1_1lucene_1_1analysis.html','../../');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Packages</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Package org.apache.lucene.analysis</div>  </div>
</div><!--header-->
<div class="contents">

<p>Text analysis.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Packages</h2></td></tr>
<tr class="memitem:d0/d96/namespaceorg_1_1apache_1_1lucene_1_1analysis_1_1standard"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d96/namespaceorg_1_1apache_1_1lucene_1_1analysis_1_1standard.html">standard</a></td></tr>
<tr class="memdesc:d0/d96/namespaceorg_1_1apache_1_1lucene_1_1analysis_1_1standard"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast, general-purpose grammar-based tokenizer <a class="el" href="../../de/dcb/classorg_1_1apache_1_1lucene_1_1analysis_1_1standard_1_1_standard_tokenizer.html">org.apache.lucene.analysis.standard.StandardTokenizer</a> implements the Word Break rules from the Unicode Text Segmentation algorithm, as specified in <a href="http://unicode.org/reports/tr29/">Unicode Standard Annex #29</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/dab/namespaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes"><td class="memItemLeft" align="right" valign="top">package &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dab/namespaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes.html">tokenattributes</a></td></tr>
<tr class="memdesc:db/dab/namespaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-purpose attributes for text analysis. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">Analyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> builds TokenStreams, which analyze text.  <a href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd1/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer_wrapper.html">AnalyzerWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension to <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">Analyzer</a> suitable for Analyzers which wrap other Analyzers.  <a href="../../d6/dd1/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d0d/classorg_1_1apache_1_1lucene_1_1analysis_1_1_caching_token_filter.html">CachingTokenFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used if the token attributes of a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> are intended to be consumed more than once.  <a href="../../d0/d0d/classorg_1_1apache_1_1lucene_1_1analysis_1_1_caching_token_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d31/classorg_1_1apache_1_1lucene_1_1analysis_1_1_character_utils.html">CharacterUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to write tokenizers or token filters.  <a href="../../d4/d31/classorg_1_1apache_1_1lucene_1_1analysis_1_1_character_utils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4b/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_array_map.html">CharArrayMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that stores key Strings as char[]'s in a hash table.  <a href="../../dd/d4b/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_array_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d7c/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_array_set.html">CharArraySet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple class that stores Strings as char[]'s in a hash table.  <a href="../../d9/d7c/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_array_set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html">CharFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a> can be chained to filter a Reader They can be used as <a class="el" href="../../">java.io.Reader</a> with additional offset correction.  <a href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/de2/classorg_1_1apache_1_1lucene_1_1analysis_1_1_delegating_analyzer_wrapper.html">DelegatingAnalyzerWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analyzer wrapper, that doesn't allow to wrap components or readers.  <a href="../../d3/de2/classorg_1_1apache_1_1lucene_1_1analysis_1_1_delegating_analyzer_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html">FilteringTokenFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for TokenFilters that may remove tokens.  <a href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d50/classorg_1_1apache_1_1lucene_1_1analysis_1_1_graph_token_filter.html">GraphTokenFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> that exposes its input stream as a graph.  <a href="../../d8/d50/classorg_1_1apache_1_1lucene_1_1analysis_1_1_graph_token_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d8c/classorg_1_1apache_1_1lucene_1_1analysis_1_1_lower_case_filter.html">LowerCaseFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes token text to lower case.  <a href="../../df/d8c/classorg_1_1apache_1_1lucene_1_1analysis_1_1_lower_case_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ReusableStringReader</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class to enable reuse of the string reader by <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html#a2462b9a313cb185ce36c36862d68d168">Analyzer#tokenStream(String,String)</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbd/classorg_1_1apache_1_1lucene_1_1analysis_1_1_stop_filter.html">StopFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes stop words from a token stream.  <a href="../../d8/dbd/classorg_1_1apache_1_1lucene_1_1analysis_1_1_stop_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/ddb/classorg_1_1apache_1_1lucene_1_1analysis_1_1_stopword_analyzer_base.html">StopwordAnalyzerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for Analyzers that need to make use of stopword sets.  <a href="../../de/ddb/classorg_1_1apache_1_1lucene_1_1analysis_1_1_stopword_analyzer_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html">TokenFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> is a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> whose input is another <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>.  <a href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">Tokenizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a> is a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> whose input is a Reader.  <a href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">TokenStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a></code> enumerates the sequence of tokens, either from <a class="el" href="../../">Field</a>s of a <a class="el" href="../../">Document</a> or from query text.  <a href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/da7/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream_to_automaton.html">TokenStreamToAutomaton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consumes a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> and creates an <a class="el" href="../../">Automaton</a> where the transition labels are UTF8 bytes (or Unicode code points if unicodeArcs is true) from the <a class="el" href="../../">TermToBytesRefAttribute</a>.  <a href="../../d2/da7/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream_to_automaton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db7/classorg_1_1apache_1_1lucene_1_1analysis_1_1_wordlist_loader.html">WordlistLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loader for text files that represent a list of stopwords.  <a href="../../d6/db7/classorg_1_1apache_1_1lucene_1_1analysis_1_1_wordlist_loader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Text analysis. </p>
<p>API and code to convert text into indexable/searchable tokens. Covers <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> and related classes.</p>
<h2>Parsing? Tokenization? Analysis!</h2>
<p>Lucene, an indexing and search library, accepts only plain text input. </p><h2>Parsing</h2>
<p>Applications that build their search capabilities upon Lucene may support documents in various formats &ndash; HTML, XML, PDF, Word &ndash; just to name a few. Lucene does not care about the <em>Parsing</em> of these and other document formats, and it is the responsibility of the application using Lucene to use an appropriate <em>Parser</em> to convert the original format into plain text before passing that plain text to Lucene. </p><h2>Tokenization</h2>
<p>Plain text passed to Lucene for indexing goes through a process generally called tokenization. Tokenization is the process of breaking input text into small indexing elements &ndash; tokens. The way input text is broken into tokens heavily influences how people will then be able to search for that text. For instance, sentences beginnings and endings can be identified to provide for more accurate phrase and proximity searches (though sentence identification is not provided by Lucene). </p>
<p>In some cases simply breaking the input text into tokens is not enough &ndash; a deeper <em>Analysis</em> may be needed. Lucene includes both pre- and post-tokenization analysis facilities. </p>
<p>Pre-tokenization analysis can include (but is not limited to) stripping HTML markup, and transforming or removing text matching arbitrary patterns or sets of fixed strings. </p>
<p>There are many post-tokenization steps that can be done, including (but not limited to): </p>
<ul>
<li>
<a href="http://en.wikipedia.org/wiki/Stemming">Stemming</a> &ndash; Replacing words with their stems. For instance with English stemming "bikes" is replaced with "bike"; now query "bike" can find both documents containing "bike" and those containing "bikes".  </li>
<li>
<a href="http://en.wikipedia.org/wiki/Stop_words">Stop Words Filtering</a> &ndash; Common words like "the", "and" and "a" rarely add any value to a search. Removing them shrinks the index size and increases performance. It may also reduce some "noise" and actually improve search quality.  </li>
<li>
<a href="http://en.wikipedia.org/wiki/Text_normalization">Text Normalization</a> &ndash; Stripping accents and other character markings can make for better searching.  </li>
<li>
<a href="http://en.wikipedia.org/wiki/Synonym">Synonym Expansion</a> &ndash; Adding in synonyms at the same token position as the current word can mean better matching when users search with words in the synonym set.  </li>
</ul>
<h2>Core Analysis</h2>
<p>The analysis package provides the mechanism to convert Strings and Readers into tokens that can be indexed by Lucene. There are four main classes in the package from which all analysis processes are derived. These are: </p>
<ul>
<li>
<a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> &ndash; An <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code> is responsible for supplying a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">org.apache.lucene.analysis.TokenStream</a> which can be consumed by the indexing and searching processes. See below for more information on implementing your own <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a>. Most of the time, you can use an anonymous subclass of <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a>.  </li>
<li>
<a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html">org.apache.lucene.analysis.CharFilter</a> &ndash; <code><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a></code> extends <a class="el" href="../../">java.io.Reader</a> to transform the text before it is tokenized, while providing corrected character offsets to account for these modifications. This capability allows highlighting to function over the original text when indexed tokens are created from <code><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a></code>-modified text with offsets that are not the same as those in the original text. <a class="el" href="../../">org.apache.lucene.analysis.Tokenizer#setReader(java.io.Reader)</a> accept <code><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a></code>s. <code><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a></code>s may be chained to perform multiple pre-tokenization modifications.  </li>
<li>
<a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a> &ndash; A <code><a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a></code> is a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">org.apache.lucene.analysis.TokenStream</a> and is responsible for breaking up incoming text into tokens. In many cases, an <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> will use a <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a> as the first step in the analysis process. However, to modify text prior to tokenization, use a <a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html">org.apache.lucene.analysis.CharFilter</a> subclass (see above).  </li>
<li>
<a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html">org.apache.lucene.analysis.TokenFilter</a> &ndash; A <code><a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a></code> is a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">org.apache.lucene.analysis.TokenStream</a> and is responsible for modifying tokens that have been created by the <code><a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a></code>. Common modifications performed by a <code><a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a></code> are: deletion, stemming, synonym injection, and case folding. Not all <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code>s require <code><a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a></code>s.  </li>
</ul>
<h2>Hints, Tips and Traps</h2>
<p>The relationship between <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> and <a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html">org.apache.lucene.analysis.CharFilter</a>s, <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a>s, and <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html">org.apache.lucene.analysis.TokenFilter</a>s is sometimes confusing. To ease this confusion, here is some clarifications: </p>
<ul>
<li>
The <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> is a <b>factory</b> for analysis chains. <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code>s don't process text, <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code>s construct <code><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a></code>s, <code><a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a></code>s, and/or <code><a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a></code>s that process text. An <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code> has two tasks: to produce <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">org.apache.lucene.analysis.TokenStream</a>s that accept a reader and produces tokens, and to wrap or otherwise pre-process <a class="el" href="../../">java.io.Reader</a> objects.  </li>
<li>
The <a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html">org.apache.lucene.analysis.CharFilter</a> is a subclass of <a class="el" href="../../">java.io.Reader</a> that supports offset tracking.  </li>
<li>
The<a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a> is only responsible for &lt;u&gt;breaking&lt;/u&gt; the input text into tokens.  </li>
<li>
The<a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html">org.apache.lucene.analysis.TokenFilter</a> modifies a stream of tokens and their contents.  </li>
<li>
<a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a> is a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">org.apache.lucene.analysis.TokenStream</a>, but <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> is not.  </li>
<li>
<a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> is "field aware", but <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a> is not. <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a>s may take a field name into account when constructing the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html">org.apache.lucene.analysis.TokenStream</a>.  </li>
</ul>
<p>If you want to use a particular combination of <code><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a></code>s, a <code><a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a></code>, and some <code><a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a></code>s, the simplest thing is often an create an anonymous subclass of <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a>, provide <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html#a565668ef0edfae76ee88e52071729394">org.apache.lucene.analysis.Analyzer#createComponents(String)</a> and perhaps also <a class="el" href="../../">java.io.Reader)</a>. However, if you need the same set of components over and over in many places, you can make a subclass of <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a>. In fact, Apache Lucene supplies a large family of <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code> classes that deliver useful analysis chains. The most common of these is the <a href="../../{@docRoot}/org/apache/lucene/analysis/standard/StandardAnalyzer.html">StandardAnalyzer</a>. Many applications will have a long and industrious life with nothing more than the <code>StandardAnalyzer</code>. The <a href="../../{@docRoot}/../analyzers-common/overview-summary.html">analyzers-common</a> library provides many pre-existing analyzers for various languages. The analysis-common library also allows to configure a custom <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> without subclassing using the <a href="../../{@docRoot}/../analyzers-common/org/apache/lucene/analysis/custom/CustomAnalyzer.html">CustomAnalyzer</a> class. </p>
<p>Aside from the <code>StandardAnalyzer</code>, Lucene includes several components containing analysis components, all under the 'analysis' directory of the distribution. Some of these support particular languages, others integrate external components. The 'common' subdirectory has some noteworthy general-purpose analyzers, including the <a href="../../{@docRoot}/../analyzers-common/org/apache/lucene/analysis/miscellaneous/PerFieldAnalyzerWrapper.html">PerFieldAnalyzerWrapper</a>. Most <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code>s perform the same operation on all <a class="el" href="../../d0/d8b/classorg_1_1apache_1_1lucene_1_1document_1_1_field.html">org.apache.lucene.document.Field</a>s. The PerFieldAnalyzerWrapper can be used to associate a different <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code> with different <a class="el" href="../../d0/d8b/classorg_1_1apache_1_1lucene_1_1document_1_1_field.html">org.apache.lucene.document.Field</a>s. There is a great deal of functionality in the analysis area, you should study it carefully to find the pieces you need. </p>
<p>Analysis is one of the main causes of slow indexing. Simply put, the more you analyze the slower the indexing (in most cases). Perhaps your application would be just fine using the simple WhitespaceTokenizer combined with a <a class="el" href="../../d8/dbd/classorg_1_1apache_1_1lucene_1_1analysis_1_1_stop_filter.html" title="Removes stop words from a token stream. ">StopFilter</a>. The benchmark/ library can be useful for testing out the speed of the analysis process. </p>
<h2>Invoking the <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></h2>
<p>Applications usually do not invoke analysis &ndash; Lucene does it for them. Applications construct <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code>s and pass then into Lucene, as follows: </p>
<ul>
<li>
At indexing, as a consequence of <a class="el" href="../../">addDocument(doc)</a>, the <code><a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a></code> in effect for indexing is invoked for each indexed field of the added document.  </li>
<li>
At search, a <code>QueryParser</code> may invoke the <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> during parsing. Note that for some queries, analysis does not take place, e.g. wildcard queries.  </li>
</ul>
<p>However an application might invoke Analysis of any text for testing or for any other purpose, something like: </p>
<pre class="prettyprint" id="analysis-workflow">
    Version matchVersion = Version.LUCENE_XY; // Substitute desired Lucene version for XY
    <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> analyzer = new StandardAnalyzer(matchVersion); // or any other analyzer
    <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> ts = analyzer.tokenStream("myfield", new StringReader("some text goes here"));
    // The <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> class will construct the <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a>, TokenFilter(s), and CharFilter(s),
    //   and pass the resulting Reader to the <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a>.
    OffsetAttribute offsetAtt = ts.addAttribute(OffsetAttribute.class);</pre><pre class="prettyprint" id="analysis-workflow">    try {
      ts.reset(); // Resets this stream to the beginning. (Required)
      while (ts.incrementToken()) {
        // Use <a class="el" href="../../dc/d09/classorg_1_1apache_1_1lucene_1_1util_1_1_attribute_source.html#a45a70ab8702d70929af12f5720db908b">org.apache.lucene.util.AttributeSource#reflectAsString(boolean)</a>
        // for token stream debugging.
        System.out.println("token: " + ts.reflectAsString(true));</pre><pre class="prettyprint" id="analysis-workflow">        System.out.println("token start offset: " + offsetAtt.startOffset());
        System.out.println("  token end offset: " + offsetAtt.endOffset());
      }
      ts.end();   // Perform end-of-stream operations, e.g. set the final offset.
    } finally {
      ts.close(); // Release resources associated with this stream.
    }
</pre> <h2>Indexing Analysis vs. Search Analysis</h2>
<p>Selecting the "correct" analyzer is crucial for search quality, and can also affect indexing and search performance. The "correct" analyzer for your application will depend on what your input text looks like and what problem you are trying to solve. Lucene java's wiki page <a href="http://wiki.apache.org/lucene-java/AnalysisParalysis">AnalysisParalysis</a> provides some data on "analyzing your analyzer". Here are some rules of thumb: </p><ol>
<li>
Test test test... (did we say test?) </li>
<li>
Beware of too much analysis &ndash; it might hurt indexing performance. </li>
<li>
Start with the same analyzer for indexing and search, otherwise searches would not find what they are supposed to... </li>
<li>
In some cases a different analyzer is required for indexing and search, for instance: <ul>
<li>
Certain searches require more stop words to be filtered. (i.e. more than those that were filtered at indexing.) </li>
<li>
Query expansion by synonyms, acronyms, auto spell correction, etc. </li>
</ul>
This might sometimes require a modified analyzer &ndash; see the next section on how to do that.  </li>
</ol>
<h2>Implementing your own <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> and Analysis Components</h2>
<p>Creating your own <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> is straightforward. Your <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> should subclass <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a>. It can use existing analysis components &mdash; CharFilter(s) <em>(optional)</em>, a <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a>, and TokenFilter(s) <em>(optional)</em> &mdash; or components you create, or a combination of existing and newly created components. Before pursuing this approach, you may find it worthwhile to explore the <a href="../../{@docRoot}/../analyzers-common/overview-summary.html">analyzers-common</a> library and/or ask on the <a href="http://lucene.apache.org/core/discussion.html">java-user@lucene.apache.org mailing list</a> first to see if what you need already exists. If you are still committed to creating your own <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a>, have a look at the source code of any one of the many samples located in this package. </p>
<p>The following sections discuss some aspects of implementing your own analyzer. </p>
<h3>Field Section Boundaries</h3>
<p>When <a class="el" href="../../dc/d7d/classorg_1_1apache_1_1lucene_1_1document_1_1_document.html#a268cf823fbc27bd64242fabe7b3b3831">document.add(field)</a> is called multiple times for the same field name, we could say that each such call creates a new section for that field in that document. In fact, a separate call to <a class="el" href="../../">tokenStream(field,reader)</a> would take place for each of these so called "sections". However, the default <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> behavior is to treat all these sections as one large section. This allows phrase search and proximity search to seamlessly cross boundaries between these "sections". In other words, if a certain field "f" is added like this: </p>
<pre class="prettyprint">
    document.add(new Field("f","first ends",...);
    document.add(new Field("f","starts two",...);
    indexWriter.addDocument(document);
</pre> <p>Then, a phrase search for "ends starts" would find that document. Where desired, this behavior can be modified by introducing a "position gap" between consecutive field "sections", simply by overriding <a class="el" href="../../">Analyzer.getPositionIncrementGap(fieldName)</a>: </p>
<pre class="prettyprint">
  Version matchVersion = Version.LUCENE_XY; // Substitute desired Lucene version for XY
  <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> myAnalyzer = new StandardAnalyzer(matchVersion) {
    public int getPositionIncrementGap(String fieldName) {
      return 10;
    }
  };
</pre> <h3>End of Input Cleanup</h3>
<p>At the ends of each field, Lucene will call the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#af822078377b7b63782298300ce7d24d3">org.apache.lucene.analysis.TokenStream#end()</a>. The components of the token stream (the tokenizer and the token filters) <b>must</b> put accurate values into the token attributes to reflect the situation at the end of the field. The Offset attribute must contain the final offset (the total number of characters processed) in both start and end. Attributes like PositionLength must be correct. </p>
<p>The base method<a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#af822078377b7b63782298300ce7d24d3">org.apache.lucene.analysis.TokenStream#end()</a> sets PositionIncrement to 0, which is required. Other components must override this method to fix up the other attributes. </p>
<h3>Token Position Increments</h3>
<p>By default, <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> arranges for the <a class="el" href="../../d0/d56/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_position_increment_attribute.html#a5e5ca37ce47363960591460bbf700251">position increment</a> of all tokens to be one. This means that the position stored for that token in the index would be one more than that of the previous token. Recall that phrase and proximity searches rely on position info. </p>
<p>If the selected analyzer filters the stop words "is" and "the", then for a document containing the string "blue is the sky", only the tokens "blue", "sky" are indexed, with position("sky") = 3 + position("blue"). Now, a phrase query "blue is the sky" would find that document, because the same analyzer filters the same stop words from that query. But the phrase query "blue sky" would not find that document because the position increment between "blue" and "sky" is only 1. </p>
<p><br />
 If this behavior does not fit the application needs, the query parser needs to be configured to not take position increments into account when generating phrase queries. </p>
<p>Note that a filter that filters <b>out</b> tokens <b>must</b> increment the position increment in order not to generate corrupt tokenstream graphs. Here is the logic used by <a class="el" href="../../d8/dbd/classorg_1_1apache_1_1lucene_1_1analysis_1_1_stop_filter.html" title="Removes stop words from a token stream. ">StopFilter</a> to increment positions when filtering out tokens: </p>
<pre class="prettyprint">
  public <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> tokenStream(final String fieldName, Reader reader) {
    final <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> ts = someAnalyzer.tokenStream(fieldName, reader);
    <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> res = new TokenStream() {
      CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
      PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);</pre><pre class="prettyprint">      public boolean incrementToken() throws IOException {
        int extraIncrement = 0;
        while (true) {
          boolean hasNext = ts.incrementToken();
          if (hasNext) {
            if (stopWords.contains(termAtt.toString())) {
              extraIncrement += posIncrAtt.getPositionIncrement(); // filter this word
              continue;
            } 
            if (extraIncrement &gt; 0) {
              posIncrAtt.setPositionIncrement(posIncrAtt.getPositionIncrement()+extraIncrement);
            }
          }
          return hasNext;
        }
      }
    };
    return res;
  }
</pre> <p>A few more use cases for modifying position increments are: </p>
<ol>
<li>
Inhibiting phrase and proximity matches in sentence boundaries &ndash; for this, a tokenizer that identifies a new sentence can add 1 to the position increment of the first token of the new sentence. </li>
<li>
Injecting synonyms &ndash; synonyms of a token should be created at the same position as the original token, and the output order of the original token and the injected synonym is undefined as long as they both leave from the same position. As result, all synonyms of a token would be considered to appear in exactly the same position as that token, and so would they be seen by phrase and proximity searches. For multi-token synonyms to work correctly, you should use <div class="fragment"><div class="line">SynoymGraphFilter </div></div><!-- fragment --> at search time only. </li>
</ol>
<h3>Token Position Length</h3>
<p>By default, all tokens created by Analyzers and Tokenizers have a <a class="el" href="../../dc/df3/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_position_length_attribute.html#a50446a1b82487531630b61212cd16887">position length</a> of one. This means that the token occupies a single position. This attribute is not indexed and thus not taken into account for positional queries, but is used by eg. suggesters. </p>
<p>The main use case for positions lengths is multi-word synonyms. With single-word synonyms, setting the position increment to 0 is enough to denote the fact that two words are synonyms, for example: </p>
<table summary="table showing position increments of 1 and 0 for red and magenta, respectively">
<tr>
<td>Term</td><td>red</td><td>magenta </td></tr>
<tr>
<td>Position increment</td><td>1</td><td>0 </td></tr>
</table>
<p>Given that position(magenta) = 0 + position(red), they are at the same position, so anything working with analyzers will return the exact same result if you replace "magenta" with "red" in the input. However, multi-word synonyms are more tricky. Let's say that you want to build a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> where "IBM" is a synonym of "Internal Business Machines". Position increments are not enough anymore: </p>
<table summary="position increments where international is zero">
<tr>
<td>Term</td><td>IBM</td><td>International</td><td>Business</td><td>Machines </td></tr>
<tr>
<td>Position increment</td><td>1</td><td>0</td><td>1</td><td>1 </td></tr>
</table>
<p>The problem with this token stream is that "IBM" is at the same position as "International" although it is a synonym with "International Business Machines" as a whole. Setting the position increment of "Business" and "Machines" to 0 wouldn't help as it would mean than "International" is a synonym of "Business". The only way to solve this issue is to make "IBM" span across 3 positions, this is where position lengths come to rescue. </p>
<table summary="position lengths where IBM is three">
<tr>
<td>Term</td><td>IBM</td><td>International</td><td>Business</td><td>Machines </td></tr>
<tr>
<td>Position increment</td><td>1</td><td>0</td><td>1</td><td>1 </td></tr>
<tr>
<td>Position length</td><td>3</td><td>1</td><td>1</td><td>1 </td></tr>
</table>
<p>This new attribute makes clear that "IBM" and "International Business Machines" start and end at the same positions. </p>
<p><a class="anchor" id="corrupt"></a> </p><h3>How to not write corrupt token streams</h3>
<p>There are a few rules to observe when writing custom Tokenizers and TokenFilters: </p>
<ul>
<li>
The first position increment must be &gt; 0. </li>
<li>
Positions must not go backward. </li>
<li>
Tokens that have the same start position must have the same start offset. </li>
<li>
Tokens that have the same end position (taking into account the position length) must have the same end offset. </li>
<li>
Tokenizers must call <a class="el" href="../../dc/d09/classorg_1_1apache_1_1lucene_1_1util_1_1_attribute_source.html#a6b530997a6c53b3b84ffa4b59433cc30">org.apache.lucene.util.AttributeSource#clearAttributes()</a> in incrementToken(). </li>
<li>
Tokenizers must override <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#af822078377b7b63782298300ce7d24d3">org.apache.lucene.analysis.TokenStream#end()</a>, and pass the final offset (the total number of input characters processed) to both parameters of <a class="el" href="../../d3/d99/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_offset_attribute.html#a19fc5ab44cde51fdac213c015d796c3b">org.apache.lucene.analysis.tokenattributes.OffsetAttribute#setOffset(int, int)</a>. </li>
</ul>
<p>Although these rules might seem easy to follow, problems can quickly happen when chaining badly implemented filters that play with positions and offsets, such as synonym or n-grams filters. Here are good practices for writing correct filters: </p>
<ul>
<li>
Token filters should not modify offsets. If you feel that your filter would need to modify offsets, then it should probably be implemented as a tokenizer. </li>
<li>
Token filters should not insert positions. If a filter needs to add tokens, then they should all have a position increment of 0. </li>
<li>
When they add tokens, token filters should call <a class="el" href="../../dc/d09/classorg_1_1apache_1_1lucene_1_1util_1_1_attribute_source.html#a6b530997a6c53b3b84ffa4b59433cc30">org.apache.lucene.util.AttributeSource#clearAttributes()</a> first. </li>
<li>
When they remove tokens, token filters should increment the position increment of the following token. </li>
<li>
Token filters should preserve position lengths. </li>
</ul>
<h2><a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> API</h2>
<p>"Flexible Indexing" summarizes the effort of making the Lucene indexer pluggable and extensible for custom index formats. A fully customizable indexer means that users will be able to store custom data structures on disk. Therefore the analysis API must transport custom types of data from the documents to the indexer. (It also supports communications amongst the analysis components.) </p>
<h3>Attribute and AttributeSource</h3>
<p>Classes <a class="el" href="../../d9/de5/interfaceorg_1_1apache_1_1lucene_1_1util_1_1_attribute.html">org.apache.lucene.util.Attribute</a> and <a class="el" href="../../dc/d09/classorg_1_1apache_1_1lucene_1_1util_1_1_attribute_source.html">org.apache.lucene.util.AttributeSource</a> serve as the basis upon which the analysis elements of "Flexible Indexing" are implemented. An Attribute holds a particular piece of information about a text token. For example, <a class="el" href="../../d5/da2/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_char_term_attribute.html">org.apache.lucene.analysis.tokenattributes.CharTermAttribute</a> contains the term text of a token, and <a class="el" href="../../d3/d99/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_offset_attribute.html">org.apache.lucene.analysis.tokenattributes.OffsetAttribute</a> contains the start and end character offsets of a token. An AttributeSource is a collection of Attributes with a restriction: there may be only one instance of each attribute type. <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> now extends AttributeSource, which means that one can add Attributes to a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>. Since <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> extends <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>, all filters are also AttributeSources. </p>
<p>Lucene provides seven Attributes out of the box: </p>
<table rules="all" frame="box" cellpadding="3" summary="common bundled attributes">
<tr>
<td><a class="el" href="../../d5/da2/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_char_term_attribute.html">org.apache.lucene.analysis.tokenattributes.CharTermAttribute</a> </td><td>The term text of a token. Implements <a class="el" href="../../">java.lang.CharSequence</a> (providing methods length() and charAt(), and allowing e.g. for direct use with regular expression <a class="el" href="../../">java.util.regex.Matcher</a>s) and <a class="el" href="../../">java.lang.Appendable</a> (allowing the term text to be appended to.)   </td></tr>
<tr>
<td><a class="el" href="../../d3/d99/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_offset_attribute.html">org.apache.lucene.analysis.tokenattributes.OffsetAttribute</a> </td><td>The start and end offset of a token in characters.  </td></tr>
<tr>
<td><a class="el" href="../../d0/d56/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_position_increment_attribute.html">org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute</a> </td><td>See above for detailed information about position increment.  </td></tr>
<tr>
<td><a class="el" href="../../dc/df3/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_position_length_attribute.html">org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute</a> </td><td>The number of positions occupied by a token.  </td></tr>
<tr>
<td><a class="el" href="../../d1/d7b/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_payload_attribute.html">org.apache.lucene.analysis.tokenattributes.PayloadAttribute</a> </td><td>The payload that a Token can optionally have.  </td></tr>
<tr>
<td><a class="el" href="../../d0/de9/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_type_attribute.html">org.apache.lucene.analysis.tokenattributes.TypeAttribute</a> </td><td>The type of the token. Default is 'word'.  </td></tr>
<tr>
<td><a class="el" href="../../d0/daa/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_flags_attribute.html">org.apache.lucene.analysis.tokenattributes.FlagsAttribute</a> </td><td>Optional flags a token can have.  </td></tr>
<tr>
<td><a class="el" href="../../d2/d90/interfaceorg_1_1apache_1_1lucene_1_1analysis_1_1tokenattributes_1_1_keyword_attribute.html">org.apache.lucene.analysis.tokenattributes.KeywordAttribute</a> </td><td>Keyword-aware TokenStreams/-Filters skip modification of tokens that return true from this attribute's isKeyword() method.   </td></tr>
</table>
<h3>More Requirements for Analysis Component Classes</h3>
<p>Due to the historical development of the API, there are some perhaps less than obvious requirements to implement analysis components classes. </p><h4 id="analysis-lifetime">Token Stream Lifetime</h4>
<p>The code fragment of the <a href="../../#analysis-workflow">analysis workflow protocol</a> above shows a token stream being obtained, used, and then left for garbage. However, that does not mean that the components of that token stream will, in fact, be discarded. The default is just the opposite. <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html">org.apache.lucene.analysis.Analyzer</a> applies a reuse strategy to the tokenizer and the token filters. It will reuse them. For each new input, it calls <a class="el" href="../../">org.apache.lucene.analysis.Tokenizer#setReader(java.io.Reader)</a> to set the input. Your components must be prepared for this scenario, as described below. </p><h4><a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a></h4>
<ul>
<li>
You should create your tokenizer class by extending <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a>.  </li>
<li>
Your tokenizer <b>must</b> override <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#af822078377b7b63782298300ce7d24d3">org.apache.lucene.analysis.TokenStream#end()</a>. Your implementation <b>must</b> call <code>super.end()</code>. It must set a correct final offset into the offset attribute, and finish up and other attributes to reflect the end of the stream.  </li>
<li>
If your tokenizer overrides <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#a4168e900661f1acdbad401403fb8ff55">org.apache.lucene.analysis.TokenStream#reset()</a> or <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#a7afb0e534a240861cbfb349ed10cd434">org.apache.lucene.analysis.TokenStream#close()</a>, it <b>must</b> call the corresponding superclass method.  </li>
</ul>
<h4>Token Filter</h4>
<p>You should create your token filter class by extending <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html">org.apache.lucene.analysis.TokenFilter</a>. If your token filter overrides <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#a4168e900661f1acdbad401403fb8ff55">org.apache.lucene.analysis.TokenStream#reset()</a>, <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#af822078377b7b63782298300ce7d24d3">org.apache.lucene.analysis.TokenStream#end()</a> or <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html#a7afb0e534a240861cbfb349ed10cd434">org.apache.lucene.analysis.TokenStream#close()</a>, it <b>must</b> call the corresponding superclass method. </p><h4>Creating delegates</h4>
<p>Forwarding classes (those which extend <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html">org.apache.lucene.analysis.Tokenizer</a> but delegate selected logic to another tokenizer) must also set the reader to the delegate in the overridden <a class="el" href="../../">org.apache.lucene.analysis.Tokenizer#reset()</a> method, e.g.: </p><pre class="prettyprint">
    public class ForwardingTokenizer extends <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a> {
       private <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a> delegate;
       ...
       { }
       public void reset() {
          super.reset();
          delegate.setReader(this.input);
          delegate.reset();
       }
    }
  </pre> <h3>Testing Your Analysis Component</h3>
<p>The lucene-test-framework component defines <a href="../../{@docRoot}/../test-framework/org/apache/lucene/analysis/BaseTokenStreamTestCase.html">BaseTokenStreamTestCase</a>. By extending this class, you can create JUnit tests that validate that your <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> and/or analysis components correctly implement the protocol. The checkRandomData methods of that class are particularly effective in flushing out errors. </p>
<h3>Using the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> API</h3>
<p>There are a few important things to know in order to use the new API efficiently which are summarized here. You may want to walk through the example below first and come back to this section afterwards. </p><ol>
<li>
Please keep in mind that an AttributeSource can only have one instance of a particular Attribute. Furthermore, if a chain of a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> and multiple TokenFilters is used, then all TokenFilters in that chain share the Attributes with the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>.  </li>
<li>
Attribute instances are reused for all tokens of a document. Thus, a TokenStream/-Filter needs to update the appropriate Attribute(s) in incrementToken(). The consumer, commonly the Lucene indexer, consumes the data in the Attributes and then calls incrementToken() again until it returns false, which indicates that the end of the stream was reached. This means that in each call of incrementToken() a TokenStream/-Filter can safely overwrite the data in the Attribute instances.  </li>
<li>
For performance reasons a TokenStream/-Filter should add/get Attributes during instantiation; i.e., create an attribute in the constructor and store references to it in an instance variable. Using an instance variable instead of calling addAttribute()/getAttribute() in incrementToken() will avoid attribute lookups for every token in the document.  </li>
<li>
All methods in AttributeSource are idempotent, which means calling them multiple times always yields the same result. This is especially important to know for addAttribute(). The method takes the <b>type</b> (<code>Class</code>) of an Attribute as an argument and returns an <b>instance</b>. If an Attribute of the same type was previously added, then the already existing instance is returned, otherwise a new instance is created and returned. Therefore TokenStreams/-Filters can safely call addAttribute() with the same Attribute type multiple times. Even consumers of TokenStreams should normally call addAttribute() instead of getAttribute(), because it would not fail if the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> does not have this Attribute (getAttribute() would throw an IllegalArgumentException, if the Attribute is missing). More advanced code could simply check with hasAttribute(), if a <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> has it, and may conditionally leave out processing for extra performance. </li>
</ol>
<h3>Example</h3>
<p>In this example we will create a WhiteSpaceTokenizer and use a LengthFilter to suppress all words that have only two or fewer characters. The LengthFilter is part of the Lucene core and its implementation will be explained here to illustrate the usage of the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> API. </p>
<p>Then we will develop a custom Attribute, a PartOfSpeechAttribute, and add another filter to the chain which utilizes the new custom attribute, and call it PartOfSpeechTaggingFilter. </p>
<h4>Whitespace tokenization</h4>
<pre class="prettyprint">
public class MyAnalyzer extends <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> {</pre><pre class="prettyprint">  private Version matchVersion;</pre><pre class="prettyprint">  public MyAnalyzer(Version matchVersion) {
    this.matchVersion = matchVersion;
  }</pre><pre class="prettyprint">  { }
  protected TokenStreamComponents createComponents(String fieldName) {
    return new TokenStreamComponents(new WhitespaceTokenizer(matchVersion));
  }</pre><pre class="prettyprint">  public static void main(String[] args) throws IOException {
    // text to tokenize
    final String text = "This is a demo of the TokenStream API";</pre><pre class="prettyprint">    Version matchVersion = Version.LUCENE_XY; // Substitute desired Lucene version for XY
    MyAnalyzer analyzer = new MyAnalyzer(matchVersion);
    <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> stream = analyzer.tokenStream("field", new StringReader(text));</pre><pre class="prettyprint">    // get the CharTermAttribute from the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>
    CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);</pre><pre class="prettyprint">    try {
      stream.reset();</pre><pre class="prettyprint">      // print all tokens until stream is exhausted
      while (stream.incrementToken()) {
        System.out.println(termAtt.toString());
      }</pre><pre class="prettyprint">      stream.end();
    } finally {
      stream.close();
    }
  }
}
</pre><p> In this easy example a simple white space tokenization is performed. In main() a loop consumes the stream and prints the term text of the tokens by accessing the CharTermAttribute that the WhitespaceTokenizer provides. Here is the output: </p><pre>
This
is
a
demo
of
the
new
<a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>
API
</pre> <h4>Adding a LengthFilter</h4>
<p>We want to suppress all tokens that have 2 or less characters. We can do that easily by adding a LengthFilter to the chain. Only the <code>createComponents()</code> method in our analyzer needs to be changed: </p><pre class="prettyprint">
  { }
  protected TokenStreamComponents createComponents(String fieldName) {
    final <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a> source = new WhitespaceTokenizer(matchVersion);
    <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> result = new LengthFilter(true, source, 3, Integer.MAX_VALUE);
    return new TokenStreamComponents(source, result);
  }
</pre><p> Note how now only words with 3 or more characters are contained in the output: </p><pre>
This
demo
the
new
<a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>
API
</pre><p> Now let's take a look how the LengthFilter is implemented: </p><pre class="prettyprint">
public final class LengthFilter extends <a class="el" href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html" title="Abstract base class for TokenFilters that may remove tokens. ">FilteringTokenFilter</a> {</pre><pre class="prettyprint">  private final int min;
  private final int max;</pre><pre class="prettyprint">  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);</pre><pre class="prettyprint">  &amp;#47;**<ul>
<li>Create a new LengthFilter. This will filter out tokens whose</li>
<li>CharTermAttribute is either too short</li>
<li>(&lt; min) or too long (&gt; max).</li>
<li>{ <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">}</td><td>version the Lucene match version</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>{ <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">}</td><td>in      the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> to consume</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>{ <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">}</td><td>min     the minimum length</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>{ <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">}</td><td>max     the maximum length
   *&amp;#47;
 public LengthFilter(Version version, TokenStream in, int min, int max) {
    super(version, in);
    this.min = min;
    this.max = max;
  }</td></tr>
  </table>
  </dd>
</dl>
{ }
  public boolean accept() {
    final int len = termAtt.length();
    return (len &gt;= min &amp;&amp; len &lt;= max);
  }</li>
</ul>
</pre><pre class="prettyprint">}
</pre> <p>In LengthFilter, the CharTermAttribute is added and stored in the instance variable <code>termAtt</code>. Remember that there can only be a single instance of CharTermAttribute in the chain, so in our example the <code>addAttribute()</code> call in LengthFilter returns the CharTermAttribute that the WhitespaceTokenizer already added. </p>
<p>The tokens are retrieved from the input stream in <a class="el" href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html" title="Abstract base class for TokenFilters that may remove tokens. ">FilteringTokenFilter</a>'s <code>incrementToken()</code> method (see below), which calls LengthFilter's <code>accept()</code> method. By looking at the term text in the CharTermAttribute, the length of the term can be determined and tokens that are either too short or too long are skipped. Note how <code>accept()</code> can efficiently access the instance variable; no attribute lookup is necessary. The same is true for the consumer, which can simply use local references to the Attributes. </p>
<p>LengthFilter extends <a class="el" href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html" title="Abstract base class for TokenFilters that may remove tokens. ">FilteringTokenFilter</a>: </p>
<pre class="prettyprint">
public abstract class <a class="el" href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html" title="Abstract base class for TokenFilters that may remove tokens. ">FilteringTokenFilter</a> extends <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> {</pre><pre class="prettyprint">  private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);</pre><pre class="prettyprint">  &amp;#47;**
   * Create a new <a class="el" href="../../dd/d79/classorg_1_1apache_1_1lucene_1_1analysis_1_1_filtering_token_filter.html" title="Abstract base class for TokenFilters that may remove tokens. ">FilteringTokenFilter</a>.
   * { <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">}</td><td>in      the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> to consume
   *&amp;#47;
  public FilteringTokenFilter(Version version, TokenStream in) {
    super(in);
  }</td></tr>
  </table>
  </dd>
</dl>
&amp;#47;** Override this method and return if the current input token should be returned by incrementToken. *&amp;#47;
  protected abstract boolean accept() throws IOException;</pre><pre class="prettyprint">  { }
  public final boolean incrementToken() throws IOException {
    int skippedPositions = 0;
    while (input.incrementToken()) {
      if (accept()) {
        if (skippedPositions != 0) {
          posIncrAtt.setPositionIncrement(posIncrAtt.getPositionIncrement() + skippedPositions);
        }
        return true;
      }
      skippedPositions += posIncrAtt.getPositionIncrement();
    }
    // reached EOS -- return false
    return false;
  }</pre><pre class="prettyprint">  { }
  public void reset() throws IOException {
    super.reset();
  }</pre><pre class="prettyprint">}
</pre><h4>Adding a custom Attribute</h4>
<p>Now we're going to implement our own custom Attribute for part-of-speech tagging and call it consequently <code>PartOfSpeechAttribute</code>. First we need to define the interface of the new Attribute: </p><pre class="prettyprint">
  public interface PartOfSpeechAttribute extends Attribute {
    public static enum PartOfSpeech {
      Noun, Verb, Adjective, Adverb, Pronoun, Preposition, Conjunction, Article, Unknown
    }</pre><pre class="prettyprint">    public void setPartOfSpeech(PartOfSpeech pos);</pre><pre class="prettyprint">    public PartOfSpeech getPartOfSpeech();
  }
</pre> <p>Now we also need to write the implementing class. The name of that class is important here: By default, Lucene checks if there is a class with the name of the Attribute with the suffix 'Impl'. In this example, we would consequently call the implementing class <code>PartOfSpeechAttributeImpl</code>. </p>
<p>This should be the usual behavior. However, there is also an expert-API that allows changing these naming conventions: <a class="el" href="../../d0/d72/classorg_1_1apache_1_1lucene_1_1util_1_1_attribute_factory.html">org.apache.lucene.util.AttributeFactory</a>. The factory accepts an Attribute interface as argument and returns an actual instance. You can implement your own factory if you need to change the default behavior. </p>
<p>Now here is the actual class that implements our new Attribute. Notice that the class has to extend <a class="el" href="../../dd/da0/classorg_1_1apache_1_1lucene_1_1util_1_1_attribute_impl.html">org.apache.lucene.util.AttributeImpl</a>: </p>
<pre class="prettyprint">
public final class PartOfSpeechAttributeImpl extends AttributeImpl 
                                  implements PartOfSpeechAttribute {</pre><pre class="prettyprint">  private PartOfSpeech pos = PartOfSpeech.Unknown;</pre><pre class="prettyprint">  public void setPartOfSpeech(PartOfSpeech pos) {
    this.pos = pos;
  }</pre><pre class="prettyprint">  public PartOfSpeech getPartOfSpeech() {
    return pos;
  }</pre><pre class="prettyprint">  { }
  public void clear() {
    pos = PartOfSpeech.Unknown;
  }</pre><pre class="prettyprint">  { }
  public void copyTo(AttributeImpl target) {
    ((PartOfSpeechAttribute) target).setPartOfSpeech(pos);
  }
}
</pre> <p>This is a simple Attribute implementation has only a single variable that stores the part-of-speech of a token. It extends the <code>AttributeImpl</code> class and therefore implements its abstract methods <code>clear()</code> and <code>copyTo()</code>. Now we need a <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> that can set this new PartOfSpeechAttribute for each token. In this example we show a very naive filter that tags every word with a leading upper-case letter as a 'Noun' and all other words as 'Unknown'. </p>
<pre class="prettyprint">
  public static class PartOfSpeechTaggingFilter extends <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> {
    PartOfSpeechAttribute posAtt = addAttribute(PartOfSpeechAttribute.class);
    CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);</pre><pre class="prettyprint">    protected PartOfSpeechTaggingFilter(TokenStream input) {
      super(input);
    }</pre><pre class="prettyprint">    public boolean incrementToken() throws IOException {
      if (!input.incrementToken()) {return false;}
      posAtt.setPartOfSpeech(determinePOS(termAtt.buffer(), 0, termAtt.length()));
      return true;
    }</pre><pre class="prettyprint">    // determine the part of speech for the given term
    protected PartOfSpeech determinePOS(char[] term, int offset, int length) {
      // naive implementation that tags every uppercased word as noun
      if (length &gt; 0 &amp;&amp; Character.isUpperCase(term[0])) {
        return PartOfSpeech.Noun;
      }
      return PartOfSpeech.Unknown;
    }
  }
</pre> <p>Just like the LengthFilter, this new filter stores references to the attributes it needs in instance variables. Notice how you only need to pass in the interface of the new Attribute and instantiating the correct class is automatically taken care of. </p>
<p>Now we need to add the filter to the chain in MyAnalyzer:</p>
<pre class="prettyprint">
  { }
  protected TokenStreamComponents createComponents(String fieldName) {
    final <a class="el" href="../../d7/dc6/classorg_1_1apache_1_1lucene_1_1analysis_1_1_tokenizer.html" title="A Tokenizer is a TokenStream whose input is a Reader. ">Tokenizer</a> source = new WhitespaceTokenizer(matchVersion);
    <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> result = new LengthFilter(true, source, 3, Integer.MAX_VALUE);
    result = new PartOfSpeechTaggingFilter(result);
    return new TokenStreamComponents(source, result);
  }
</pre><p> Now let's look at the output: </p><pre>
This
demo
the
new
<a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>
API
</pre><p> Apparently it hasn't changed, which shows that adding a custom attribute to a TokenStream/Filter chain does not affect any existing consumers, simply because they don't know the new Attribute. Now let's change the consumer to make use of the new PartOfSpeechAttribute and print it out: </p><pre class="prettyprint">
  public static void main(String[] args) throws IOException {
    // text to tokenize
    final String text = "This is a demo of the TokenStream API";</pre><pre class="prettyprint">    MyAnalyzer analyzer = new MyAnalyzer();
    <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> stream = analyzer.tokenStream("field", new StringReader(text));</pre><pre class="prettyprint">    // get the CharTermAttribute from the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>
    CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);</pre><pre class="prettyprint">    // get the PartOfSpeechAttribute from the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>
    PartOfSpeechAttribute posAtt = stream.addAttribute(PartOfSpeechAttribute.class);</pre><pre class="prettyprint">    try {
      stream.reset();</pre><pre class="prettyprint">      // print all tokens until stream is exhausted
      while (stream.incrementToken()) {
        System.out.println(termAtt.toString() + ": " + posAtt.getPartOfSpeech());
      }</pre><pre class="prettyprint">      stream.end();
    } finally {
      stream.close();
    }
  }
</pre><p> The change that was made is to get the PartOfSpeechAttribute from the <a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a> and print out its contents in the while loop that consumes the stream. Here is the new output: </p><pre>
This: Noun
demo: Unknown
the: Unknown
new: Unknown
<a class="el" href="../../db/d98/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_stream.html" title="A TokenStream enumerates the sequence of tokens, either from Fields of a Document or from query text...">TokenStream</a>: Noun
API: Noun
</pre><p> Each word is now followed by its assigned PartOfSpeech tag. Of course this is a naive part-of-speech tagging. The word 'This' should not even be tagged as noun; it is only spelled capitalized because it is the first word of a sentence. Actually this is a good opportunity for an exercise. To practice the usage of the new API the reader could now write an Attribute and <a class="el" href="../../d4/d9f/classorg_1_1apache_1_1lucene_1_1analysis_1_1_token_filter.html" title="A TokenFilter is a TokenStream whose input is another TokenStream. ">TokenFilter</a> that can specify for each word if it was the first token of a sentence or not. Then the PartOfSpeechTaggingFilter can make use of this knowledge and only tag capitalized words as nouns if not the first word of a sentence (we know, this is still not a correct behavior, but hey, it's a good exercise). As a small hint, this is how the new Attribute class could begin: </p><pre class="prettyprint">
  public class FirstTokenOfSentenceAttributeImpl extends AttributeImpl
                              implements FirstTokenOfSentenceAttribute {</pre><pre class="prettyprint">    private boolean firstToken;</pre><pre class="prettyprint">    public void setFirstToken(boolean firstToken) {
      this.firstToken = firstToken;
    }</pre><pre class="prettyprint">    public boolean getFirstToken() {
      return firstToken;
    }</pre><pre class="prettyprint">    { }
    public void clear() {
      firstToken = false;
    }</pre><pre class="prettyprint">  ...
</pre> <h4>Adding a <a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a> chain</h4>
<p>Analyzers take Java <a class="el" href="../../">java.io.Reader</a>s as input. Of course you can wrap your Readers with <a class="el" href="../../">java.io.FilterReader</a>s to manipulate content, but this would have the big disadvantage that character offsets might be inconsistent with your original text. </p>
<p><a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html">org.apache.lucene.analysis.CharFilter</a> is designed to allow you to pre-process input like a FilterReader would, but also preserve the original offsets associated with those characters. This way mechanisms like highlighting still work correctly. CharFilters can be chained. </p>
<p>Example: </p><pre class="prettyprint">
public class MyAnalyzer extends <a class="el" href="../../d6/d78/classorg_1_1apache_1_1lucene_1_1analysis_1_1_analyzer.html" title="An Analyzer builds TokenStreams, which analyze text. ">Analyzer</a> {</pre><pre class="prettyprint">  { }
  protected TokenStreamComponents createComponents(String fieldName) {
    return new TokenStreamComponents(new MyTokenizer());
  }</pre><pre class="prettyprint">  { }
  protected Reader initReader(String fieldName, Reader reader) {
    // wrap the Reader in a <a class="el" href="../../de/dbf/classorg_1_1apache_1_1lucene_1_1analysis_1_1_char_filter.html" title="Subclasses of CharFilter can be chained to filter a Reader They can be used as java.io.Reader with additional offset correction. ">CharFilter</a> chain.
    return new SecondCharFilter(new FirstCharFilter(reader));
  }
}
</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>org</b></li><li class="navelem"><b>apache</b></li><li class="navelem"><a class="el" href="../../d8/d76/namespaceorg_1_1apache_1_1lucene.html">lucene</a></li><li class="navelem"><a class="el" href="../../d7/d36/namespaceorg_1_1apache_1_1lucene_1_1analysis.html">analysis</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
